[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332671832",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332671832",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332671832,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjY3MTgzMg==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-27T22:17:54Z",
    "updated_at": "2017-09-27T22:17:54Z",
    "author_association": "MEMBER",
    "body": "D'oh. Of course. This is per connection and this goes away when the connection is severed.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332704386",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332704386",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332704386,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjcwNDM4Ng==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T01:53:39Z",
    "updated_at": "2017-09-28T01:53:39Z",
    "author_association": "MEMBER",
    "body": "I'm really unsure of how I could work around this to buffer messages to replay to clients when they reconnect.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332882812",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332882812",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332882812,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg4MjgxMg==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T15:59:32Z",
    "updated_at": "2017-09-28T15:59:32Z",
    "author_association": "MEMBER",
    "body": "Yeah, it would need to go somewhere else. Right now, we create a zmq socket per websocket connection. That zmq socket is destroyed when the websocket connection is lost.\r\n\r\nWhat we would need to do is:\r\n\r\n1. leave the *zmq* connections open after the websocket goes away (potentially with a timeout, but kernel shutdown is also a reasonable time to close)\r\n1. when clients close, start buffering\r\n1. persist transient state of cell:msg_id mapping to be restored on reconnect, so that the right handlers are hooked up to deal with the resuming messages\r\n\r\nI think this is going to be tricky without moving the document state to the server, but may still be worth exploring.\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332884224",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332884224",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332884224,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg4NDIyNA==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T16:04:12Z",
    "updated_at": "2017-09-28T16:04:12Z",
    "author_association": "MEMBER",
    "body": "> I think this is going to be tricky without moving the document state to the server, but may still be worth exploring.\r\n\r\nYeah I still want that in the long term, it's hard to keep promising that in the short term though.\r\n\r\n> Yeah, it would need to go somewhere else. Right now, we create a zmq socket per websocket connection. That zmq socket is destroyed when the websocket connection is lost.\r\n\r\nYikes, alright. Do we just keep one extra zmq socket around then in that case. I see now how I was spinning some wheels hopelessly -- the zmq connection is created here when the websocket connection is created.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332886018",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332886018",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332886018,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg4NjAxOA==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T16:10:27Z",
    "updated_at": "2017-09-28T16:10:44Z",
    "author_association": "MEMBER",
    "body": ">  Do we just keep one extra zmq socket around then in that case.\r\n\r\nFor the lost connection case (not new tab, new browser, etc.), then replay should be fine, and all we need to track is the session_id, which is what identifies a browser session. This should work:\r\n\r\n1. on websocket close, leave zmq stream open and start buffering instead of closing, as we do now.\r\n2. on websocket open, check session_id and reconnect to zmq_stream and replay if one already exists for that session_id. If session_id *doesn't* match, clear any buffers that may be open (i.e. don't allow multiple viewers to have this resume behavior on the same kernel).",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332886546",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332886546",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332886546,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg4NjU0Ng==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T16:12:19Z",
    "updated_at": "2017-09-28T16:12:19Z",
    "author_association": "MEMBER",
    "body": "Saving the hairy cell:msg_id problem for another task makes sense to me. We can focus on the lost connection case, which will improve several real use cases.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332890259",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332890259",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332890259,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg5MDI1OQ==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T16:25:56Z",
    "updated_at": "2017-09-28T16:26:02Z",
    "author_association": "MEMBER",
    "body": "Based on conversations with Min, I'm going to take a new stab at this within the `ZMQChannelsHandler` and:\r\n\r\n* Attaching the buffer to the kernel object\r\n* There will only be one buffer per kernel\r\n* This is only intended to make reconnecting with the same tab work well (we aren't worried about multiple sessions since we don't work well with multiple tabs now anyways...)",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/332892359",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-332892359",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 332892359,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjg5MjM1OQ==",
    "user": {
      "login": "blink1073",
      "id": 2096628,
      "node_id": "MDQ6VXNlcjIwOTY2Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2096628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blink1073",
      "html_url": "https://github.com/blink1073",
      "followers_url": "https://api.github.com/users/blink1073/followers",
      "following_url": "https://api.github.com/users/blink1073/following{/other_user}",
      "gists_url": "https://api.github.com/users/blink1073/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blink1073/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blink1073/subscriptions",
      "organizations_url": "https://api.github.com/users/blink1073/orgs",
      "repos_url": "https://api.github.com/users/blink1073/repos",
      "events_url": "https://api.github.com/users/blink1073/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blink1073/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-28T16:33:35Z",
    "updated_at": "2017-09-28T16:34:46Z",
    "author_association": "MEMBER",
    "body": "<image src=\"https://user-images.githubusercontent.com/2096628/30978722-00644dd4-a441-11e7-80e0-7e3dda6333f4.png\" width=400>\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/333891548",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-333891548",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 333891548,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzg5MTU0OA==",
    "user": {
      "login": "alexgarel",
      "id": 144788,
      "node_id": "MDQ6VXNlcjE0NDc4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144788?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexgarel",
      "html_url": "https://github.com/alexgarel",
      "followers_url": "https://api.github.com/users/alexgarel/followers",
      "following_url": "https://api.github.com/users/alexgarel/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexgarel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexgarel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexgarel/subscriptions",
      "organizations_url": "https://api.github.com/users/alexgarel/orgs",
      "repos_url": "https://api.github.com/users/alexgarel/repos",
      "events_url": "https://api.github.com/users/alexgarel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexgarel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T16:08:40Z",
    "updated_at": "2017-10-03T16:09:22Z",
    "author_association": "NONE",
    "body": "Just as you implements this particular mechanism, in case you want, you may also think of multi concurrent user notebooks in this form:\r\n\r\n* multiple user are working on the same notebook\r\n* as soon as a user submit a cell, it's value is updated in the other user notebook (in case of conflict, interface propose something)\r\n* as soon as the result is ready, it is displayed in all notebooks\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/333907877",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-333907877",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 333907877,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzkwNzg3Nw==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T16:50:44Z",
    "updated_at": "2017-10-03T16:50:44Z",
    "author_association": "MEMBER",
    "body": "We're going to tackle multi user concurrent notebooks with a server side state of the notebook, which is not done today. This is only a band aid. Check out https://github.com/jupyterlab/jupyterlab-google-drive for the current alpha for realtime.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/333917827",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-333917827",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 333917827,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzkxNzgyNw==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T17:25:01Z",
    "updated_at": "2017-10-03T17:25:01Z",
    "author_association": "MEMBER",
    "body": "I've pushed an implementation that works. It's still an unbounded list.\r\n\r\n- buffer is per-kernel\r\n- session_key is stored because only the same session that is buffered will resume properly\r\n- on any new connection to a kernel, buffer is flushed.\r\n  If session_key matches, buffer is replayed.\r\n  Otherwise, it is discarded (this will be refreshed pages, new browser windows).\r\n- buffer is an unbounded list for now\r\n- buffer is never discarded until the kernel shuts down\r\n\r\nThings we could do:\r\n\r\n1. limit the lifetime of the buffer (e.g. expire and close after 10 minutes?)\r\n2. limit the size of the buffer (msg count and/or total bytes)\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/333963934",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-333963934",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 333963934,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzk2MzkzNA==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-03T20:12:47Z",
    "updated_at": "2017-10-03T20:12:47Z",
    "author_association": "MEMBER",
    "body": "```\r\nPASS ws_closed_error: kernel_idle.Kernel was triggered\r\nTimeout for http://localhost:8888/a@b/\r\nIs the notebook server running?\r\nFAIL \"function () {\r\n        return this.evaluate(function (events) {\r\n            return IPython._events_triggered.length >= events.length;\r\n        }, [events]);\r\n    }\" did not evaluate to something truthy in 10000ms\r\n#    type: uncaughtError\r\n#    file: /home/travis/build/jupyter/notebook/notebook/tests/services/kernel.js\r\n#    error: \"function () {\r\n        return this.evaluate(function (events) {\r\n            return IPython._events_triggered.length >= events.length;\r\n        }, [events]);\r\n    }\" did not evaluate to something truthy in 10000ms\r\n#    stack: not provided\r\nCaptured console.log:\r\n```\r\n\r\nShould we skip this test for now?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334076121",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334076121",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334076121,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDA3NjEyMQ==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T07:49:00Z",
    "updated_at": "2017-10-04T07:49:00Z",
    "author_association": "MEMBER",
    "body": "> Should we skip this test for now?\r\n\r\nNo, I think it's a real bug.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334138532",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334138532",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334138532,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDEzODUzMg==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T12:25:44Z",
    "updated_at": "2017-10-04T12:25:44Z",
    "author_association": "MEMBER",
    "body": "Bug fixed. I also improved the dialog/status handling when connection is lost.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334147106",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334147106",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334147106,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDE0NzEwNg==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T13:00:15Z",
    "updated_at": "2017-10-04T13:00:15Z",
    "author_association": "MEMBER",
    "body": "Here's what it looks like now with a connection drop and reconnect in the middle of execution:\r\n\r\n![replay](https://user-images.githubusercontent.com/151929/31176860-94269892-a914-11e7-9282-5fa9b70e62f7.gif)\r\n\r\nThe dialog is dismissed automatically when the connection is restored.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334221220",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334221220",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334221220,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDIyMTIyMA==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T16:57:41Z",
    "updated_at": "2017-10-04T16:57:41Z",
    "author_association": "MEMBER",
    "body": "This is working pretty well. Even for a flaky VPN + wifi dropoff, I'm only losing one message within a one second gap.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334284477",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334284477",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334284477,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDI4NDQ3Nw==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T20:47:25Z",
    "updated_at": "2017-10-04T20:51:24Z",
    "author_association": "MEMBER",
    "body": "Including some discussion from other communication channels: This is never going to be rigorous without adding things like ack/generation counters that we probably shouldn't get into before shifting document state entirely server-side for real-time. Messages can still be lost of the notebook server and the frontend disagree about when the disconnect happens (e.g. when there are more intermediate services than a localhost proxy). But it will still solve a real annoyance for a lot of people.\r\n\r\n@rgbkrk what more do you think we should do here? Should we implement limits and/or expiry? We could also start with a bool flag to just turn it off in case it causes trouble.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334289333",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334289333",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334289333,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDI4OTMzMw==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T21:05:55Z",
    "updated_at": "2017-10-04T21:05:55Z",
    "author_association": "MEMBER",
    "body": "The only other things that I think we could add are:\r\n\r\n* Making this a memory bounded queue, though I don't think we have to do it in this PR\r\n* The boolean flag you suggest is probably a really good idea\r\n\r\nI definitely agree this will solve a real annoyance for a _lot_ of people, so it doesn't have to perfect this go-round. We've certainly got longer term plans for making this better with server side state, so we can only take this band-aid so far.\r\n\r\nIf we wanted to be a bit more crazy, imagine for a moment that we stored N messages before the disconnect happened and added those to the buffer once we realize it's disconnected. We could end up duplicating outputs, but at the same time we'd still end up with some of the missed ones.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334294002",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334294002",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334294002,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDI5NDAwMg==",
    "user": {
      "login": "blink1073",
      "id": 2096628,
      "node_id": "MDQ6VXNlcjIwOTY2Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2096628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blink1073",
      "html_url": "https://github.com/blink1073",
      "followers_url": "https://api.github.com/users/blink1073/followers",
      "following_url": "https://api.github.com/users/blink1073/following{/other_user}",
      "gists_url": "https://api.github.com/users/blink1073/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blink1073/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blink1073/subscriptions",
      "organizations_url": "https://api.github.com/users/blink1073/orgs",
      "repos_url": "https://api.github.com/users/blink1073/repos",
      "events_url": "https://api.github.com/users/blink1073/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blink1073/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T21:24:51Z",
    "updated_at": "2017-10-04T21:24:51Z",
    "author_association": "MEMBER",
    "body": "What if this were implemented as a response to a message from the frontend that said \"hey, I was disconnected but I'm back, here's the last msg_id I got, please send the rest\"?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334294591",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334294591",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334294591,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDI5NDU5MQ==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T21:27:19Z",
    "updated_at": "2017-10-04T21:27:19Z",
    "author_association": "MEMBER",
    "body": "> here's the last msg_id I got, please send the rest\r\n\r\nOooooh, I like that. I mean, it will be a bit strange as we'll be putting a new API on top of the current API over the websockets though.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334433745",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334433745",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334433745,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDQzMzc0NQ==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-05T11:09:33Z",
    "updated_at": "2017-10-05T11:09:33Z",
    "author_association": "MEMBER",
    "body": "@blink1073 that's definitely possible and would be more robust. To do that, we would need to maintain a cache of messages on *all* channels all the time, in case of dropped connections in the future, rather than only when connections are lost. Doing that points to a different mechanism, because it makes it *inevitable* that the cache gets huge, rather than possible. To do that, we need to spill to disk with an efficient culling mechanism. To me, that sounds like a job for sqlite.\r\n\r\nIf I were doing that, I would make last_msg_id part of the websocket connect request to trigger the replay.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334457505",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334457505",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334457505,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDQ1NzUwNQ==",
    "user": {
      "login": "alexgarel",
      "id": 144788,
      "node_id": "MDQ6VXNlcjE0NDc4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/144788?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alexgarel",
      "html_url": "https://github.com/alexgarel",
      "followers_url": "https://api.github.com/users/alexgarel/followers",
      "following_url": "https://api.github.com/users/alexgarel/following{/other_user}",
      "gists_url": "https://api.github.com/users/alexgarel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alexgarel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alexgarel/subscriptions",
      "organizations_url": "https://api.github.com/users/alexgarel/orgs",
      "repos_url": "https://api.github.com/users/alexgarel/repos",
      "events_url": "https://api.github.com/users/alexgarel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alexgarel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-05T13:00:50Z",
    "updated_at": "2017-10-05T13:00:50Z",
    "author_association": "NONE",
    "body": "If you use sqlite for messages, I would suggest default sqlite database should be in memory database.\r\nOf course persistent database would allow to gets past results even after a jupyter server restart ! That sounds cool. But you'll have to find a policy to remove dead kernel messages.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334771675",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334771675",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334771675,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDc3MTY3NQ==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-06T14:30:35Z",
    "updated_at": "2017-10-06T14:30:35Z",
    "author_association": "MEMBER",
    "body": "I think this is probably good to go ahead with for the time being as further enchancements are going to require a lot more coordination between the frontends and the server.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334801384",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334801384",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334801384,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDgwMTM4NA==",
    "user": {
      "login": "gnestor",
      "id": 512354,
      "node_id": "MDQ6VXNlcjUxMjM1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/512354?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gnestor",
      "html_url": "https://github.com/gnestor",
      "followers_url": "https://api.github.com/users/gnestor/followers",
      "following_url": "https://api.github.com/users/gnestor/following{/other_user}",
      "gists_url": "https://api.github.com/users/gnestor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gnestor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gnestor/subscriptions",
      "organizations_url": "https://api.github.com/users/gnestor/orgs",
      "repos_url": "https://api.github.com/users/gnestor/repos",
      "events_url": "https://api.github.com/users/gnestor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gnestor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-06T16:15:33Z",
    "updated_at": "2017-10-06T16:15:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks @rgbkrk and @minrk!!",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334809453",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334809453",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334809453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDgwOTQ1Mw==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-06T16:47:58Z",
    "updated_at": "2017-10-06T16:47:58Z",
    "author_association": "MEMBER",
    "body": "Thanks @gnestor and @minrk!",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/334927311",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-334927311",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 334927311,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDkyNzMxMQ==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-07T11:04:53Z",
    "updated_at": "2017-10-07T11:04:53Z",
    "author_association": "MEMBER",
    "body": "@alexgarel I think it can't be in-memory by default because the main point of using sqlite would be to limit how much memory the message cache will take by spilling to disk.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/428392632",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-428392632",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 428392632,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODM5MjYzMg==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-09T23:58:34Z",
    "updated_at": "2018-10-09T23:58:34Z",
    "author_association": "MEMBER",
    "body": " @rgbkrk & @minrk - First, sorry for posting this to a closed PR but it has all the necessary context.  Second, I apologize for my long windedness.  TL;DR: In looking at the buffering code, it seems like buffer replay never comes into play (at this time).\r\n\r\n I needed to look into buffering support relative to a recent NB2KG issue.  Since NB2KG proxies the notebook's kernel management to a gateway server (Kernel Gateway or Enterprise Gateway), I was concerned that buffering replay wouldn't work.  However, after looking into this more deeply, I find these behaviors between traditional notebook and nb2kg-enabled notebooks to be the same.  I also find that when the network connection between the browser and notebook is dropped, the \"replay\" as indicated by the video above is not taking place from the buffering code, but, rather from ZMQ directly (at least that's my assumption).  I say this because I don't see any debug entries about buffering messages and replaying or discarding them.  Instead, those messages are produced only after one closes the notebook browser tab, then opens that same active notebook again (which Kyle mentions above as well in describing when the PR changes take place).  As a result, I don't understand when the buffering replay will actually occur since it seems like re-opening an active notebook triggers the creation of a new session - which indirectly is part of the key (along with kernel_id) into the replayability of buffered messages. \r\n\r\n Do I have the correct understanding with respect to the state of buffering and its replay?  If not, under what circumstances does the implemented buffering get replayed?\r\n\r\n Could you explain why session is part of the key for determining whether the buffered messages are to be replayed or not?  I'm guessing it represents the \"channel instances\" since different connections of the same kernel instance will use different channels - is that right?  If so, would it be possible to equate the channel \"sets\" from the previous (buffered) session to the new session and drop the use of session_key?\r\n\r\nThank you for your time and increasing my understanding.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/428429139",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-428429139",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 428429139,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODQyOTEzOQ==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-10T03:52:29Z",
    "updated_at": "2018-10-10T03:52:29Z",
    "author_association": "MEMBER",
    "body": "They are attached to a session because otherwise the frontend has no way of associating output messages (by `msg_id`) to the cells they originated from.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/428758094",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-428758094",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 428758094,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODc1ODA5NA==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-10T22:42:46Z",
    "updated_at": "2018-10-10T22:42:46Z",
    "author_association": "MEMBER",
    "body": "Thanks Kyle.  So I think buffered message usage from NB2KG is doubly screwed (once replay is figured out) because the session_key generated in the Gateway server will be different than that generated in the (client) Notebook server where the messages are derived.   Is this session key the same value as the session entry in each message (or can be derived from them)?  If so, it would be nice if the message buffer initialized the session key in that manner.\r\n\r\nAny hints on how to trigger buffer replays (and not discards)?  If not, I'll post in gitter.\r\n\r\nThanks.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/428762284",
    "html_url": "https://github.com/jupyter/notebook/pull/2871#issuecomment-428762284",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2871",
    "id": 428762284,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyODc2MjI4NA==",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-10T23:03:42Z",
    "updated_at": "2018-10-10T23:03:42Z",
    "author_association": "MEMBER",
    "body": "I'm never in gitter, hopefully you'll find someone to help.\r\n\r\nI'd have to sit down again with the raw session messages to know for sure. Happy to meet about this at some point in the coming weeks (I'm out of town at the moment).",
    "performed_via_github_app": null
  }
]
