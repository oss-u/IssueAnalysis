[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/355893361",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-355893361",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 355893361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTg5MzM2MQ==",
    "user": {
      "login": "sschwarzer",
      "id": 744533,
      "node_id": "MDQ6VXNlcjc0NDUzMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/744533?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sschwarzer",
      "html_url": "https://github.com/sschwarzer",
      "followers_url": "https://api.github.com/users/sschwarzer/followers",
      "following_url": "https://api.github.com/users/sschwarzer/following{/other_user}",
      "gists_url": "https://api.github.com/users/sschwarzer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sschwarzer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sschwarzer/subscriptions",
      "organizations_url": "https://api.github.com/users/sschwarzer/orgs",
      "repos_url": "https://api.github.com/users/sschwarzer/repos",
      "events_url": "https://api.github.com/users/sschwarzer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sschwarzer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-08T06:48:23Z",
    "updated_at": "2018-01-08T06:48:23Z",
    "author_association": "NONE",
    "body": "I'm not familiar with the Jupyter code, so my assumption about how the deadlock happens may be wrong. I only described what _I think_ happens.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/355945859",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-355945859",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 355945859,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTk0NTg1OQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-08T11:46:10Z",
    "updated_at": "2018-01-08T11:46:10Z",
    "author_association": "MEMBER",
    "body": "The trouble is that while you're waiting on the event, it's not processing the messages trigger the callback. Executing code blocks the event loop. There isn't a good way to do this in general, but I'll try to play around with it.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/369186699",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-369186699",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 369186699,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTE4NjY5OQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-28T09:54:00Z",
    "updated_at": "2018-02-28T09:54:00Z",
    "author_association": "MEMBER",
    "body": "I don't think there's a great way to do this. Calling `get_ipython().kernel.do_one_iteration()` should process incoming messages, but it's likely to end up in a mess, because:\r\n\r\n- If there are more execution requests queued, it will process those (running later cells) before the current cell finishes.\r\n- It may change state, e.g. for redirecting output to appear under a particular cell, which will produce unexpected results when the rest of the code in that cell executes. The assumption that one cell executes at a time is built into our kernel machinery.\r\n\r\nSo I don't think it's really feasible to synchronously run Javascript on the frontend.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/381132997",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-381132997",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 381132997,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4MTEzMjk5Nw==",
    "user": {
      "login": "nukadelic",
      "id": 6582633,
      "node_id": "MDQ6VXNlcjY1ODI2MzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6582633?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nukadelic",
      "html_url": "https://github.com/nukadelic",
      "followers_url": "https://api.github.com/users/nukadelic/followers",
      "following_url": "https://api.github.com/users/nukadelic/following{/other_user}",
      "gists_url": "https://api.github.com/users/nukadelic/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nukadelic/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nukadelic/subscriptions",
      "organizations_url": "https://api.github.com/users/nukadelic/orgs",
      "repos_url": "https://api.github.com/users/nukadelic/repos",
      "events_url": "https://api.github.com/users/nukadelic/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nukadelic/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-13T13:20:31Z",
    "updated_at": "2018-04-13T13:20:31Z",
    "author_association": "NONE",
    "body": "Would it be possible to run a socket between JS-magic & Python within a notebook ? ",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/381168700",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-381168700",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 381168700,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4MTE2ODcwMA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-13T15:17:30Z",
    "updated_at": "2018-04-13T15:17:30Z",
    "author_association": "MEMBER",
    "body": "That's essentially what our [comms mechanism](http://jupyter-notebook.readthedocs.io/en/stable/comms.html) is.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/557381176",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-557381176",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 557381176,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzM4MTE3Ng==",
    "user": {
      "login": "pkerpedjiev",
      "id": 2143629,
      "node_id": "MDQ6VXNlcjIxNDM2Mjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2143629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pkerpedjiev",
      "html_url": "https://github.com/pkerpedjiev",
      "followers_url": "https://api.github.com/users/pkerpedjiev/followers",
      "following_url": "https://api.github.com/users/pkerpedjiev/following{/other_user}",
      "gists_url": "https://api.github.com/users/pkerpedjiev/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pkerpedjiev/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pkerpedjiev/subscriptions",
      "organizations_url": "https://api.github.com/users/pkerpedjiev/orgs",
      "repos_url": "https://api.github.com/users/pkerpedjiev/repos",
      "events_url": "https://api.github.com/users/pkerpedjiev/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pkerpedjiev/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-11-22T04:13:35Z",
    "updated_at": "2019-11-22T04:13:35Z",
    "author_association": "NONE",
    "body": "Is there maybe a way to iterative over comms messages synchronously? Or is that what `get_ipython().kernel.do_one_iteration()` does? \r\n\r\nRelated: https://github.com/ipython/ipykernel/issues/369",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/640328469",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-640328469",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 640328469,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0MDMyODQ2OQ==",
    "user": {
      "login": "oxbits",
      "id": 2498359,
      "node_id": "MDQ6VXNlcjI0OTgzNTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2498359?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/oxbits",
      "html_url": "https://github.com/oxbits",
      "followers_url": "https://api.github.com/users/oxbits/followers",
      "following_url": "https://api.github.com/users/oxbits/following{/other_user}",
      "gists_url": "https://api.github.com/users/oxbits/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/oxbits/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/oxbits/subscriptions",
      "organizations_url": "https://api.github.com/users/oxbits/orgs",
      "repos_url": "https://api.github.com/users/oxbits/repos",
      "events_url": "https://api.github.com/users/oxbits/events{/privacy}",
      "received_events_url": "https://api.github.com/users/oxbits/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-08T02:35:01Z",
    "updated_at": "2020-06-08T02:35:01Z",
    "author_association": "NONE",
    "body": "did anyone get any further with this ?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/651564636",
    "html_url": "https://github.com/jupyter/notebook/issues/3187#issuecomment-651564636",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/3187",
    "id": 651564636,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MTU2NDYzNg==",
    "user": {
      "login": "jorgecarleitao",
      "id": 2772607,
      "node_id": "MDQ6VXNlcjI3NzI2MDc=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2772607?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorgecarleitao",
      "html_url": "https://github.com/jorgecarleitao",
      "followers_url": "https://api.github.com/users/jorgecarleitao/followers",
      "following_url": "https://api.github.com/users/jorgecarleitao/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorgecarleitao/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorgecarleitao/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorgecarleitao/subscriptions",
      "organizations_url": "https://api.github.com/users/jorgecarleitao/orgs",
      "repos_url": "https://api.github.com/users/jorgecarleitao/repos",
      "events_url": "https://api.github.com/users/jorgecarleitao/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorgecarleitao/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-30T06:12:02Z",
    "updated_at": "2020-06-30T06:15:00Z",
    "author_association": "NONE",
    "body": "This seems to be independent of `IPython.display.display`; it also happens when the js comes from an extension. \r\n\r\nMy conclusion is the same as yours: there is a deadlock preventing the `on_msg` to execute on the same cell.\r\n\r\nAssuming a js target that just returns whatever was passed,\r\n\r\n```javascript\r\nJupyter.notebook.kernel.comm_manager.register_target('foo',\r\n    (comm) => (comm.on_msg((msg) => (comm.send(msg.content.data)))\r\n);\r\n```\r\n\r\nand a function that stores the response to a global:\r\n\r\n```python\r\nimport ipykernel.comm\r\n\r\nresult = None\r\ndef sync(content):\r\n    my_comm = ipykernel.comm.Comm(target_name='foo')\r\n\r\n    @my_comm.on_msg\r\n    def _recv(msg):\r\n        global result\r\n        result = msg['content']['data']\r\n\r\n    my_comm.send(content)\r\n```\r\n\r\nthe cell\r\n\r\n```python\r\nsync('a')\r\nprint(result)\r\n```\r\n\r\nprints `None`, even if `time.sleep(5)` is added after the `my_comm.send(content)`, but the cells \r\n\r\n```python\r\nsync('a')\r\n```\r\n\r\n```\r\nprint(result)\r\n```\r\n\r\nprints `'a'`",
    "performed_via_github_app": null
  }
]
