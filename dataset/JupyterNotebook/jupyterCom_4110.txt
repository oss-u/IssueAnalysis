[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/430921601",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-430921601",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 430921601,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMDkyMTYwMQ==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T08:28:30Z",
    "updated_at": "2018-10-18T08:28:30Z",
    "author_association": "MEMBER",
    "body": "I think it *must* be the session key of the frontend, because message buffering has to be tied to the frontend that lost its connection. Another frontend cannot consume a buffer for the frontend that initiated the buffering by disconnecting, so before replaying the buffer, we have to check that the reconnecting frontend is actually the *same* frontend, not a new one. If it's a new one, we should discard the buffer.\r\n\r\nDo you have an example where the wrong thing is happening?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/431044860",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-431044860",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 431044860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTA0NDg2MA==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-18T15:04:37Z",
    "updated_at": "2018-10-18T15:04:37Z",
    "author_association": "MEMBER",
    "body": "Thanks for the response - it's good to be able to talk about this.  I've provided an example with log outputs at the end of this comment, but first I think we need to be careful about how the _frontend_ is determined.  For example, in the cases of the gateway servers (Kernel and Enterprise), the _frontend_ is typically a remote notebook server (with its own idea of session management).  However, the gateways support kernel management directly via REST whose clients aren't necessarily running Jupyter code.  As a result, I believe its important to determine whether a given buffered message should be replayed based on server-side context.  Now whether that _context_ comes in some form from the client or is inferred by something from the original connection (that exists in the context of subsequent connections) is the key (sorry, pun intended).  FYI, session information in the REST api used by the Gateway's is currently not required, but we could perhaps require it for replays and applications would need to be made aware of that.  Then the \"servers\" extract it from the request and use that value as the replay key.\r\n\r\nQuestion.  Is it possible for the same kernel instance to have multiple client connections within the same Notebook server instance (i.e., where the buffering is occurring)?  As best as I can tell from my adventures in the kernel management stack, that is not the case, yet I get the impression that is the case or at least a goal (which seems reasonable). \r\n\r\nIt seems that \"session\" is commonly used throughout the code so that might be adding to the confusion.  There are session instances on the kernel manager and session instances in the websocket handler.  Seems like the latter's member could be renamed to imply a physical connection \"session\".  At any rate, since the entire idea of this feature is to replay messages from one physical websocket connection to another, then using an element unique to each of those connections to determine replay is not sufficient.  In this case, that element was the [ZMQChannelsHandler's session's session member](https://github.com/jupyter/notebook/blob/master/notebook/services/kernels/handlers.py#L251).  I chose to use the kernel manager's session's key value (and probably could have chosen the kernel manager's session's session member) since the kernel manager instance survives physical connection changes.\r\n\r\nHere are log outputs with DEBUG enabled.  I've removed the timestamp and application indicator to reduce horizontal scrolling.  I've also interspersed comments.\r\n\r\n```\r\n// Long-running cell started - prints a loop counter at 1 second intervals\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (busy)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (idle)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (busy)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: execute_input\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n\r\n// Browser tab closed - buffering starts with key b51e88e9-afa1-4c5a-9a31-55cfef1e2853:2d7f1fcc4e004b07bda651d90226bd03\r\n// Second half of key is the WS handler's session's session member\r\n[D] Websocket closed b51e88e9-afa1-4c5a-9a31-55cfef1e2853:2d7f1fcc4e004b07bda651d90226bd03\r\n[I] Starting buffering for b51e88e9-afa1-4c5a-9a31-55cfef1e2853:2d7f1fcc4e004b07bda651d90226bd03\r\n[D] Clearing buffer for b51e88e9-afa1-4c5a-9a31-55cfef1e2853\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] Buffering msg on b51e88e9-afa1-4c5a-9a31-55cfef1e2853:iopub\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n\r\n// Running notebook is re-selected and new tab is opened.  This WS handler's session's \r\n// member value is 0041fc9f4c07435c9cb68abe34f25c2f [*]\r\n[D] Initializing websocket connection /api/kernels/b51e88e9-afa1-4c5a-9a31-55cfef1e2853/channels\r\n[D] Opening websocket /api/kernels/b51e88e9-afa1-4c5a-9a31-55cfef1e2853/channels\r\n\r\n// New connection is detected so NB checks if there are buffered messages for that \r\n// physical connection.\r\n[D] Getting buffer for b51e88e9-afa1-4c5a-9a31-55cfef1e2853\r\n\r\n// Current session key b51e88e9-afa1-4c5a-9a31-55cfef1e2853:0041fc9f4c07435c9cb68abe34f25c2f \r\n// is not found so 7 buffered messages relative to previous connection are discarded.\r\n[D] Clearing buffer for b51e88e9-afa1-4c5a-9a31-55cfef1e2853\r\n[I] Discarding 7 buffered messages for b51e88e9-afa1-4c5a-9a31-55cfef1e2853:2d7f1fcc4e004b07bda651d90226bd03\r\n\r\n// Kernel keeps running and producing output to the logs.  However, none of this  \r\n// output is sent or displayed back to the client.  Presumably because the java-script \r\n// code has similar 'key-matching' relative to the session information embedded in the \r\n// header and parent_header for the returned messages - although I'm not sure why\r\n// messages relative to the newly established connection are also not displayed.\r\n[D] Connecting to: tcp://127.0.0.1:65244\r\n[D] Connecting to: tcp://127.0.0.1:65245\r\n[D] Connecting to: tcp://127.0.0.1:65246\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: stream\r\n\r\n// Client interrupts kernel because they know its still active (appears as busy), \r\n// but nothing is happening.  After interrupt, new cell execution produces \r\n// the expected output - until we trigger buffered messages again.\r\n[I] Kernel interrupted: b51e88e9-afa1-4c5a-9a31-55cfef1e2853\r\n[D] 204 POST /api/kernels/b51e88e9-afa1-4c5a-9a31-55cfef1e2853/interrupt (::1) 12.99ms\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: error\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (busy)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (idle)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (busy)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (idle)\r\n[D] activity on b51e88e9-afa1-4c5a-9a31-55cfef1e2853: status (idle)\r\n\r\n// Kernel returns back to idle.  \r\n// [*] I then closed the current browser tab in order to get the information relative \r\n// to that second session logged so that I could better explain why messages are not replayed.\r\n[D] Websocket closed b51e88e9-afa1-4c5a-9a31-55cfef1e2853:0041fc9f4c07435c9cb68abe34f25c2f\r\n[I] Starting buffering for b51e88e9-afa1-4c5a-9a31-55cfef1e2853:0041fc9f4c07435c9cb68abe34f25c2f\r\n[D] Clearing buffer for b51e88e9-afa1-4c5a-9a31-55cfef1e2853\r\n```\r\nI hope this helps - thanks for looking.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/431275616",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-431275616",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 431275616,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTI3NTYxNg==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-19T07:47:41Z",
    "updated_at": "2018-10-19T07:48:10Z",
    "author_association": "MEMBER",
    "body": ">  Is it possible for the same kernel instance to have multiple client connections within the same Notebook server instance (i.e., where the buffering is occurring)? \r\n\r\nYes. This is why the key must come from the client, to distinguish between clients.\r\n\r\n> In this case, that element was the ZMQChannelsHandler's session's session member.\r\n\r\nYes, this value is set [by the client](https://github.com/jupyter/notebook/blob/5.7.0/notebook/base/zmqhandlers.py#L274) at connection time, and is unique per connection (Handler instance). \"Resuming\" connections means a reconnect (new Handler) with the same session id.\r\n\r\nI think the right thing to do is for kernel gateway to set session id on its connections so that it can resume playback.\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/431395037",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-431395037",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 431395037,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTM5NTAzNw==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-19T15:06:48Z",
    "updated_at": "2018-10-19T15:06:48Z",
    "author_association": "MEMBER",
    "body": "Thank you for the response.  Sorry, but I need to persist a bit more here.\r\n\r\nPlease note this isn't just a kernel_gateway way issue.  All of the tracing and information I have provided is relative to Notebook - and others have confirmed.  The Kernel Gateway item I brought up is the fact that _REST clients_ of Kernel Gateway (those not using NB2KG) do not currently set any session information - so I was open to requiring that for those types of clients.  However, KG/EG clients using NB2KG have the same exact problem - and I was trying to point out that we should keep physically detached scenarios in mind.\r\n\r\nPlease enable DEBUG and try this.  The code you point out will produce a new value for each time a tab is opened for the same notebook \"session\". (Could you please provide the location where that value is set on the client-side?) \r\n\r\nI'm not sure if the `buffering.js` test is supposed to test this logic, but it does not.  It is more akin to the network drop scenario.\r\n\r\nThere are two `session` values in the messages sent - one in the `header` and the other in the `parent_header`.  The value in the `header` is consistent across tab invocations, the value in the `parent_header` changes for each connection and corresponds to the suffixed portion of the `session_key` used to determine replay.  What is the `session` relative to the `header` reflecting?\r\n\r\nI think there needs to be a way to better identify an actual notebook session that spans tab invocations within the same browser (although ideally it would be nice to not require the same browser session for this).",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/433454299",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-433454299",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 433454299,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzQ1NDI5OQ==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-26T15:49:54Z",
    "updated_at": "2018-10-26T15:49:54Z",
    "author_association": "MEMBER",
    "body": "I'm not finding anything in the runtime classes that can be used which spans the connection sessions but isn't scoped to the kernel.  I don't know the front-end enough to determine what kind of things persist across connections (i.e., \"tab invocations\"), but reflects that particular client.  Once something is identified that makes replays work in the standard notebook env, I will likely need to make it work relative to the gateway projects.  (Hint: solution should use a method that can be overridden which produces the 'replay key')\r\n\r\nIn the meantime, I'm inclined to recommend we change the default value of `MappingKernelManager.buffer_offline_messages` to `False` until we can find a solution -  otherwise, it just consumes server memory unnecessarily.\r\n\r\ncc: @minrk @rgbkrk ",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/434378318",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-434378318",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 434378318,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDM3ODMxOA==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-30T16:43:17Z",
    "updated_at": "2018-10-30T16:43:17Z",
    "author_association": "MEMBER",
    "body": "> Could you please provide the location where that value is set on the client-side?\r\n\r\nThe session id is set to a UUID on [instantiation of the Kernel object](https://github.com/jupyter/notebook/blob/5.7.0/notebook/static/services/kernels/kernel.js#L44), and [used here](https://github.com/jupyter/notebook/blob/5.7.0/notebook/static/services/kernels/kernel.js#L464). It is purely page-local state.\r\n\r\n>  The code you point out will produce a new value for each time a tab is opened for the same notebook \"session\". \r\n\r\nYes, and indeed it must do this, because the session id and replay buffer must be different for each connected tab, because each tab is a *different* client. This cannot be shared across client connections, even within the same browser. It is important to clarify that the buffer is *per client connection*, so a new client (a new tab is a new client, a page reload is a new client) must not get the replay buffer from a previous session.\r\n\r\n> I'm not sure if the buffering.js test is supposed to test this logic, but it does not. It is more akin to the network drop scenario.\r\n\r\nThat's correct. Because closing and reopening tabs *must not* resume the replay buffer, it doesn't test this. It tests the network drop case, which is the only case that is meant to be addressed by this logic, at least with the current notebook javascript. A new tab *might* resume it if were a more stateful application that knew how to handle messages from the previous connection (e.g. document/message state stored in localStorage or the client application), then it should also include the session id so that it can resume playback and identify itself as the same client reconnecting instead of a new client. But the way the notebook application currently works, opening a new tab doesn't have the information necessary to process resumed messages (it needs the msg_id->cell mapping, among other things), it always gets a new session.\r\n\r\n>Please enable DEBUG and try this.\r\n\r\nFrom the logs and annotations, everything is working correctly:\r\n\r\n1. tab closed, client disconnected. Buffering starts\r\n2. new tab opened which means a new client is connected. Buffer is discarded and new connection is established\r\n3. new client doesn't have information to route output messages produced by another client (previous session with the same notebook), so it doesn't route any of the outputs\r\n\r\n> I'm inclined to recommend we change the default value of MappingKernelManager.buffer_offline_messages to False\r\n\r\nNot for the default notebook server because it solves a specific and longstanding problem in the most common case: browsers whose connection is interrupted, but maybe this makes sense for the different use cases served by KG. WiFi problems, sleep/wake, etc. can all result in this issue and be helped by the current behavior with the default setup of the notebook server. This does point to a change we probably should make: if session_id is not specified by the client, we shouldn't bother buffering because there's no way to reconnect to that session.\r\n\r\n> we should keep physically detached scenarios in mind.\r\n\r\nI'm not sure what \"physically detached scenarios\" means here, can you elaborate?\r\n\r\n\r\nTo summarize:\r\n\r\n1. `session_id` should uniquely identify a client session (e.g. open notebook in a tab, qtconsole frame, etc.), where client session means a connection that knows how to handle a single stream of messages (i.e. a given UI instance - notebook tab, console window, etc.).\r\n2. reconnecting clients should use the same session id if and only if they know how to handle/route messages that were intended to go to the previous connection (i.e. for a notebook, this means they have the live, unsaved notebook state and message:cell mapping, etc.)\r\n3. since the notebook web application does not persist this state, each tab has a different session id.\r\n4. to avoid too many buffers, the kernel manager only buffers messages for the last closed client\r\n5. if a client connects and identifies itself as a different session than the last lost connection, the buffer is discarded\r\n\r\nCan you summarize the cases where KG wants replay to behave differently (i.e. steal replay from other clients, reconnect without setting session id)?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/434390995",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-434390995",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 434390995,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDM5MDk5NQ==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-30T17:15:22Z",
    "updated_at": "2018-10-30T17:15:22Z",
    "author_association": "MEMBER",
    "body": "@minrk - thank you very much for your detailed response.  It definitely helps my understanding.\r\n\r\nWe want KG/EG to behave the same way - and they do - its just that my understanding of 'client session' was skewed.  Knowing that a different tab instance is considered a different client helps tremendously.\r\n\r\nHowever, what I'm still struggling with, is how to get the buffered messages to be replayed?  If I merely disconnect the network, messages that occurred during the disconnect are indeed sent back to that notebook tab upon the network's reconnection, but NONE of the buffering logic (or replay) is performed.  Its like that buffering was performed (and \"replayed\") at a lower level - and since its the same websocket, none of the buffering logic _should_ come into play anyway.\r\n\r\nCan you please describe what steps to take to cause this replay logic to be triggered?\r\n\r\nAre there any plans to equate a user session to something akin to the token or something that spans tab invocations, but you know its the same \"user\"?\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/435070464",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-435070464",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 435070464,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTA3MDQ2NA==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-01T15:06:36Z",
    "updated_at": "2018-11-01T15:06:36Z",
    "author_association": "MEMBER",
    "body": "> Are there any plans to equate a user session to something akin to the token or something that spans tab invocations, but you know its the same \"user\"?\r\n\r\nNot at the moment, but only because there isn't anything (yet) for which that information would be used. With JupyterHub, the cookie (or token) identifies the user, but this spans browsers and doesn't distinguish between the same account being used in multiple browsers. It would not be appropriate to use `session_id` connected to any of these concepts, though.\r\n\r\n> Can you please describe what steps to take to cause this replay logic to be triggered?\r\n\r\nWhen testing this functionality, I used [these nginx and apache configs](https://gist.github.com/minrk/c373f660b3fece67b5c950e29cf16830) run in docker containers. The docker container proxies to my local notebook server. I can stop the proxy and restart it to drop and restore connections between the browser and the notebook server. The test process:\r\n\r\n1. start notebook server\r\n2. start proxy in docker\r\n3. connect browser to proxy\r\n4. open notebook, start long-running, output-producing cell, e.g. `for i in range(100): sleep(1); print(i)`\r\n5. stop proxy with `docker rm`, `docker stop`, etc.\r\n6. resume proxy, wait for messages to get replayed\r\n\r\nI ran this test just now (using nginx) with current master, and it worked as expected, dropping no messages. Note that testing via disconnecting wifi on a remote machine can have mixed results depending on the networking infrastructure, as the buffering relies on the server-side socket close event, which may take some time to register, resulting in some missed messages in the intervening window between the client connection being dropped and the server being told it happened. On my office wifi, this can take up to 60 seconds to register, so messages delivered in that window are lost, but messages after the server has been informed of the disconnect are properly buffered.\r\n\r\nThe way to do *rigorous* buffering is for the server to *always* maintain a lookback buffer for every connected websocket and for reconnects to be made with a \"last seen message\" id to know where to replay from. But the memory consequences of this are too severe to be done in-memory, so it would have to use sqlite or some such out-of-memory storage to be feasible.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/435082525",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-435082525",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 435082525,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTA4MjUyNQ==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-01T15:40:37Z",
    "updated_at": "2018-11-01T15:40:37Z",
    "author_association": "MEMBER",
    "body": "@minrk - thank you for your response.  \r\n\r\nAnd you confirmed via the Notebook server logging that the buffering logic actually took place?  I definitely see replay occurring (with the delay you describe) when dropping and reinstating network connections but it is NOT exercising the code implemented in kernelmanager.py.   If you could provide the notebook logging that shows the messages were replayed, that would be greatly appreciated.\r\n\r\nThank you for your time on this. I know my persistence is probably frustrating.\r\n\r\nI agree about the in-memory buffering and is an area of concern for the gateway projects since they service kernel management ops across multiple notebook instances. ",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/435453441",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-435453441",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 435453441,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTQ1MzQ0MQ==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T17:32:02Z",
    "updated_at": "2018-11-02T17:32:02Z",
    "author_association": "MEMBER",
    "body": "> And you confirmed via the Notebook server logging that the buffering logic actually took place?\r\n\r\nyes. Default logs:\r\n\r\n```\r\n[I 18:28:26.690 NotebookApp] Kernel started: 3cb287ba-cc3c-40c8-918c-da55cf1a7cb6\r\n[I 18:28:27.555 NotebookApp] Adapting from protocol version 5.1 (kernel 3cb287ba-cc3c-40c8-918c-da55cf1a7cb6) to 5.3 (client).\r\n[I 18:28:44.838 NotebookApp] Starting buffering for 3cb287ba-cc3c-40c8-918c-da55cf1a7cb6:2c148ae5f9ce4a8e849f4ea5d8be122f\r\n[I 18:29:00.145 NotebookApp] Adapting from protocol version 5.1 (kernel 3cb287ba-cc3c-40c8-918c-da55cf1a7cb6) to 5.3 (client).\r\n[I 18:29:00.145 NotebookApp] Restoring connection for 3cb287ba-cc3c-40c8-918c-da55cf1a7cb6:2c148ae5f9ce4a8e849f4ea5d8be122f\r\n[I 18:29:00.145 NotebookApp] Replaying 15 buffered messages\r\n```\r\n\r\nDebug logs:\r\n\r\n<details>\r\n\r\n```\r\n[D 18:29:28.917 NotebookApp] Opening websocket /api/kernels/0485b2bc-526a-42b4-af43-d9bf8126c83b/channels\r\n[D 18:29:28.917 NotebookApp] Getting buffer for 0485b2bc-526a-42b4-af43-d9bf8126c83b\r\n[D 18:29:28.917 NotebookApp] Connecting to: tcp://127.0.0.1:55468\r\n[D 18:29:28.917 NotebookApp] Connecting to: tcp://127.0.0.1:55469\r\n[D 18:29:28.918 NotebookApp] Connecting to: tcp://127.0.0.1:55470\r\n[D 18:29:28.922 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: status (busy)\r\n[D 18:29:28.924 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: status (idle)\r\n[D 18:29:28.926 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: status (busy)\r\n[D 18:29:28.929 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: status (idle)\r\n[D 18:29:29.475 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: status (busy)\r\n[D 18:29:29.476 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: execute_input\r\n[D 18:29:29.676 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:30.680 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:31.683 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:32.689 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:33.608 NotebookApp] Websocket closed 0485b2bc-526a-42b4-af43-d9bf8126c83b:877a2e6285e446828086f6e3c371a472\r\n[I 18:29:33.608 NotebookApp] Starting buffering for 0485b2bc-526a-42b4-af43-d9bf8126c83b:877a2e6285e446828086f6e3c371a472\r\n[D 18:29:33.609 NotebookApp] Clearing buffer for 0485b2bc-526a-42b4-af43-d9bf8126c83b\r\n[D 18:29:33.688 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:33.689 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:34.690 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:34.690 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:35.692 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:35.692 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:36.696 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:36.696 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:37.697 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:37.697 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:38.697 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:38.697 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:39.700 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:39.701 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:40.699 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:40.700 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:41.706 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:41.706 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:42.706 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:42.707 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:43.706 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:43.706 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:44.708 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:44.708 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:45.712 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:45.712 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:46.709 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:46.709 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:47.715 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:47.716 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:48.720 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:48.720 NotebookApp] Buffering msg on 0485b2bc-526a-42b4-af43-d9bf8126c83b:iopub\r\n[D 18:29:48.909 NotebookApp] Initializing websocket connection /api/kernels/0485b2bc-526a-42b4-af43-d9bf8126c83b/channels\r\n[I 18:29:48.910 NotebookApp] Adapting from protocol version 5.1 (kernel 0485b2bc-526a-42b4-af43-d9bf8126c83b) to 5.3 (client).\r\n[D 18:29:48.911 NotebookApp] 101 GET /api/kernels/0485b2bc-526a-42b4-af43-d9bf8126c83b/channels?session_id=877a2e6285e446828086f6e3c371a472 (192.168.99.1) 2.21ms\r\n[D 18:29:48.911 NotebookApp] Opening websocket /api/kernels/0485b2bc-526a-42b4-af43-d9bf8126c83b/channels\r\n[D 18:29:48.911 NotebookApp] Getting buffer for 0485b2bc-526a-42b4-af43-d9bf8126c83b\r\n[I 18:29:48.911 NotebookApp] Restoring connection for 0485b2bc-526a-42b4-af43-d9bf8126c83b:877a2e6285e446828086f6e3c371a472\r\n[I 18:29:48.911 NotebookApp] Replaying 16 buffered messages\r\n[D 18:29:49.717 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:50.721 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:51.719 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:52.723 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:53.723 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:54.729 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:55.729 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:56.736 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n[D 18:29:57.737 NotebookApp] activity on 0485b2bc-526a-42b4-af43-d9bf8126c83b: stream\r\n```\r\n\r\n</details>\r\n\r\n> Thank you for your time on this\r\n\r\nNo worries! I'm happy to figure this out and find what works best.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/435509680",
    "html_url": "https://github.com/jupyter/notebook/pull/4110#issuecomment-435509680",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/4110",
    "id": 435509680,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTUwOTY4MA==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-02T21:08:31Z",
    "updated_at": "2018-11-02T21:08:31Z",
    "author_association": "MEMBER",
    "body": "Awesome - thank you for the update!  I guess I'm not reproducing the correct behavior appropriately, but its great to see it in action.\r\n\r\nI will close this PR and corresponding issue.\r\n\r\nTo summarize: the code that currently exists for buffering and replay of messages corresponding to the same session works as designed.  The common misunderstanding being that closing a browser tab and activating another against the same notebook of the same browser instance is viewed as a _different_ session against which buffered messages will not be replayed, but instead discarded.  And that's exactly the behavior I see.  Thank you for the clarification.\r\n",
    "performed_via_github_app": null
  }
]
