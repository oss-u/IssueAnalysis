[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/163986607",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-163986607",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 163986607,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2Mzk4NjYwNw==",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-11T16:43:34Z",
    "updated_at": "2015-12-11T16:44:04Z",
    "author_association": "MEMBER",
    "body": "I encountered this issue before but I am not sure whether of what is the right way do address this. Indeed, if we do what you propose, a user may also be rightfully surprised that the behavior differs when\n- running two cells at once with the run-all action on the one hand\n- running the same code in a single cell on the other hand.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164047039",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164047039",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164047039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDA0NzAzOQ==",
    "user": {
      "login": "lbustelo",
      "id": 2474841,
      "node_id": "MDQ6VXNlcjI0NzQ4NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2474841?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lbustelo",
      "html_url": "https://github.com/lbustelo",
      "followers_url": "https://api.github.com/users/lbustelo/followers",
      "following_url": "https://api.github.com/users/lbustelo/following{/other_user}",
      "gists_url": "https://api.github.com/users/lbustelo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lbustelo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lbustelo/subscriptions",
      "organizations_url": "https://api.github.com/users/lbustelo/orgs",
      "repos_url": "https://api.github.com/users/lbustelo/repos",
      "events_url": "https://api.github.com/users/lbustelo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lbustelo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-11T21:03:54Z",
    "updated_at": "2015-12-11T21:03:54Z",
    "author_association": "NONE",
    "body": "I think I'm mostly concerned about seeing differences in behavior if user selects `Run All` vs executing the same set of cells but one by one manually very quickly.\n\nThe latter would then need to be smart to know that there is a cell in execution, and maybe others waiting, and place itself in a promise.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164410117",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164410117",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164410117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDQxMDExNw==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T11:04:04Z",
    "updated_at": "2015-12-14T11:04:04Z",
    "author_association": "MEMBER",
    "body": "I view the immediate submission of requests as a very important feature. We mustn't wait for the previous execution to complete before sending the next request, so chaining futures in Run All doesn't sound good to me. It also seems like a violation that code in a subsequent cell requires frontend interaction after the result of a previous cell.\n\nIf you depend on things like this, only you can know what needs to be done before subsequent executions are allowed, so you would really need to disable or override the Run All action to behave differently.\n\nWhat if Cell.execute returns a Future that resolves immediately, and your custom UI overrides that to resolve the Future at a later time? Would that give you the hook you need?\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164479379",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164479379",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164479379,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDQ3OTM3OQ==",
    "user": {
      "login": "lbustelo",
      "id": 2474841,
      "node_id": "MDQ6VXNlcjI0NzQ4NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2474841?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lbustelo",
      "html_url": "https://github.com/lbustelo",
      "followers_url": "https://api.github.com/users/lbustelo/followers",
      "following_url": "https://api.github.com/users/lbustelo/following{/other_user}",
      "gists_url": "https://api.github.com/users/lbustelo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lbustelo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lbustelo/subscriptions",
      "organizations_url": "https://api.github.com/users/lbustelo/orgs",
      "repos_url": "https://api.github.com/users/lbustelo/repos",
      "events_url": "https://api.github.com/users/lbustelo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lbustelo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T16:11:48Z",
    "updated_at": "2015-12-14T16:11:48Z",
    "author_association": "NONE",
    "body": "> I view the immediate submission of requests as a very important feature. We mustn't wait for the previous execution to complete before sending the next request, so chaining futures in Run All doesn't sound good to me. It also seems like a violation that code in a subsequent cell requires frontend interaction after the result of a previous cell.\n\nI would agree with you completely if we were just talking about notebooks where all cells are eval/response type. Meaning, once the response reaches the notebook, that cell is really done.\n\nHTML and JS magics, the COMM channel and Widgets introduce the likelihood of that more has to be executed before a cell could be consider fully done. \n\nConsider ipywidgets as another example.  I don't have concrete proof, but I think that it currently by-passes this issue all-together because it preloads all its widgets JS code ahead of time on notebook page load. If ipywidgets did not do this, there would be no guarantees that the widgets would be available for next cell's result due to async AMD loads. Since it is a close-set of widgets, it is able to implement the work-around, although it does so by impacting load times of all notebook pages regardless if they have widgets or not (for the record, declarativewidgets does the same).\n\nBelief me that I understand that this is not a simple issue. Changing the way cells are executed is changing the core of the notebook. There is also the question of how do you really know when a cell is really done. Even harder if the cell involves async loading of JS code. \n\nI think your suggestion of making Cell.execute return a promise and allow overriding might be a start, but it also is punting on the issue. I personally don't have a good solution to offer either, but do think that more discussion should take place.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164494967",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164494967",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164494967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDQ5NDk2Nw==",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T17:01:25Z",
    "updated_at": "2015-12-14T17:02:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "> If ipywidgets did not do this, there would be no guarantees that the widgets would be available for next cell's result due to async AMD loads\n\nEven the preloaded Javascript is reloaded asynchronously.\n\nI agree with @minrk that the immediate submission is important.  I think the rate of execution is something that should be controlled by the kernel, unimpeded by the client.  If you need the client to have a say in the rate at which executions occur, why not manually halt the executions while waiting for a message from the front-end?  \n\nAlternatively, alter the client to execute differently, as Min suggests.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164501576",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164501576",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164501576,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDUwMTU3Ng==",
    "user": {
      "login": "lbustelo",
      "id": 2474841,
      "node_id": "MDQ6VXNlcjI0NzQ4NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2474841?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lbustelo",
      "html_url": "https://github.com/lbustelo",
      "followers_url": "https://api.github.com/users/lbustelo/followers",
      "following_url": "https://api.github.com/users/lbustelo/following{/other_user}",
      "gists_url": "https://api.github.com/users/lbustelo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lbustelo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lbustelo/subscriptions",
      "organizations_url": "https://api.github.com/users/lbustelo/orgs",
      "repos_url": "https://api.github.com/users/lbustelo/repos",
      "events_url": "https://api.github.com/users/lbustelo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lbustelo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T17:24:48Z",
    "updated_at": "2015-12-14T17:24:48Z",
    "author_association": "NONE",
    "body": "Maybe I'm misreading this code... \nhttps://github.com/ipython/ipywidgets/blob/master/ipywidgets/static/widgets/js/utils.js#L79\nbut it seems to me that pre-registered widgets (which all ipywidgets are) causes the utils.loadClass to resolve immediately.\n\n> If you need the client to have a say in the rate at which executions occur, why not manually halt the executions while waiting for a message from the front-end?\n\nIf you tell me how I can do that... it would solve all my problems! If you are referring to putting some code on the Python side to block until a message is received... I tried that approach once. Does not work for several reasons:\n1. The kernel is blocked `busy` and the shell socket is not processed\n2. Even if we could un-block it, the frontend message could still be behind other cells in the request queue.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164540967",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164540967",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164540967,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDU0MDk2Nw==",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T19:52:55Z",
    "updated_at": "2015-12-14T19:53:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Maybe I'm misreading this code...\n\nYes I think you are, because resolving immediately != synchronous execution.  See [this jdfiddle](http://jsfiddle.net/daf5aLzp/2/)\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164543750",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164543750",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164543750,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDU0Mzc1MA==",
    "user": {
      "login": "lbustelo",
      "id": 2474841,
      "node_id": "MDQ6VXNlcjI0NzQ4NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2474841?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lbustelo",
      "html_url": "https://github.com/lbustelo",
      "followers_url": "https://api.github.com/users/lbustelo/followers",
      "following_url": "https://api.github.com/users/lbustelo/following{/other_user}",
      "gists_url": "https://api.github.com/users/lbustelo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lbustelo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lbustelo/subscriptions",
      "organizations_url": "https://api.github.com/users/lbustelo/orgs",
      "repos_url": "https://api.github.com/users/lbustelo/repos",
      "events_url": "https://api.github.com/users/lbustelo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lbustelo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T20:03:48Z",
    "updated_at": "2015-12-14T20:03:48Z",
    "author_association": "NONE",
    "body": "So it is more of a timing problem then. Since the code is preloaded, the callback is sure going to get invoked sooner than if we had to load the files remotely. And that might be fast enough to not see the issues that I'm bringing up here.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164545010",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164545010",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164545010,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDU0NTAxMA==",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T20:09:01Z",
    "updated_at": "2015-12-14T20:09:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "> 1. Even if we could un-block it, the frontend message could still be behind other cells in the request queue.\n\nGood point, but that would only apply to messages that are subject to the execution queue, right?  So if you were able to hold the kernel, by blocking, and you manually listened for comm messages (which I don't even know if this is possible right now, but if it is, it's probably ugly), the comm messages wouldn't be subject to that queue and could be received immediately, right?\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/164548847",
    "html_url": "https://github.com/jupyter/notebook/issues/839#issuecomment-164548847",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/839",
    "id": 164548847,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDU0ODg0Nw==",
    "user": {
      "login": "lbustelo",
      "id": 2474841,
      "node_id": "MDQ6VXNlcjI0NzQ4NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2474841?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lbustelo",
      "html_url": "https://github.com/lbustelo",
      "followers_url": "https://api.github.com/users/lbustelo/followers",
      "following_url": "https://api.github.com/users/lbustelo/following{/other_user}",
      "gists_url": "https://api.github.com/users/lbustelo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lbustelo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lbustelo/subscriptions",
      "organizations_url": "https://api.github.com/users/lbustelo/orgs",
      "repos_url": "https://api.github.com/users/lbustelo/repos",
      "events_url": "https://api.github.com/users/lbustelo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lbustelo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-14T20:24:07Z",
    "updated_at": "2015-12-14T20:24:07Z",
    "author_association": "NONE",
    "body": "As far as I know... both cell execution and `comm.send` messages go through `kernel.send_shell_message`. What I observed using Chrome's WebSocket inspector was my frontend comm messages all after the other cell execution.\n",
    "performed_via_github_app": null
  }
]
