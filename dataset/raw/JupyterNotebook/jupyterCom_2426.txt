[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/295214625",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-295214625",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 295214625,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5NTIxNDYyNQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-04-19T10:49:08Z",
    "updated_at": "2017-04-19T10:49:08Z",
    "author_association": "MEMBER",
    "body": "It's definitely not a good example for password storage, but a collision attack is not a plausible vector for stealing a password - an attacker would have to trick you into picking a specific long and unlikely password, which they would have to know, in order to generate a different password that results in the same hash. And if someone can persuade you to use a password they know, the collision is irrelevant. It's a good idea to move to a stronger hash anyway, but the recent news doesn't make that particularly urgent.\r\n\r\nA collision attack (making two inputs which produce the same hash) is generally much easier to do than a preimage attack (making an input which produces a given hash). The former is what has happened for SHA-1, and I don't believe it makes much difference for this use case.\r\n\r\nIf authenticating users to access the notebook is important, we recommend using [JupyterHub](http://jupyterhub.readthedocs.io/en/latest/).",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/295363485",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-295363485",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 295363485,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI5NTM2MzQ4NQ==",
    "user": {
      "login": "jnhnum1",
      "id": 549798,
      "node_id": "MDQ6VXNlcjU0OTc5OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/549798?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnhnum1",
      "html_url": "https://github.com/jnhnum1",
      "followers_url": "https://api.github.com/users/jnhnum1/followers",
      "following_url": "https://api.github.com/users/jnhnum1/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnhnum1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnhnum1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnhnum1/subscriptions",
      "organizations_url": "https://api.github.com/users/jnhnum1/orgs",
      "repos_url": "https://api.github.com/users/jnhnum1/repos",
      "events_url": "https://api.github.com/users/jnhnum1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnhnum1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-04-19T17:46:53Z",
    "updated_at": "2017-04-19T17:46:53Z",
    "author_association": "NONE",
    "body": "That's a good point; thanks.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/529151833",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-529151833",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 529151833,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTE1MTgzMw==",
    "user": {
      "login": "nealmcb",
      "id": 119472,
      "node_id": "MDQ6VXNlcjExOTQ3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/119472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nealmcb",
      "html_url": "https://github.com/nealmcb",
      "followers_url": "https://api.github.com/users/nealmcb/followers",
      "following_url": "https://api.github.com/users/nealmcb/following{/other_user}",
      "gists_url": "https://api.github.com/users/nealmcb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nealmcb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nealmcb/subscriptions",
      "organizations_url": "https://api.github.com/users/nealmcb/orgs",
      "repos_url": "https://api.github.com/users/nealmcb/repos",
      "events_url": "https://api.github.com/users/nealmcb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nealmcb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-09-07T22:26:22Z",
    "updated_at": "2019-09-07T22:26:22Z",
    "author_association": "NONE",
    "body": "The current hashing method is indeed very insecure, but not really because it uses SHA-1.\r\n\r\nThe problem is that it doesn't iterate the hash, making the hash function so blazing fast that brute-force attacks, using newly-available fast hardware, are way too tempting, even with a salt.\r\nThe fact that a collision was found just underscores the speed with which hashes can be done now, and the need for massive numbers of iterations.\r\n\r\nOnly doing a single iteration is madness. As even the hashlib documentation stated long ago:\r\n> As of 2013, at least 100,000 iterations of SHA-256 are suggested.\r\n\r\nSince then, hardware acceleration has expanded speeds tremendously, and a homemade rig can try 26 billion trial passwords a second. Even passwords which were once considered pretty strong can be cheaply cracked these days via online services.\r\n\r\nOffhand, pull request #3793 to use bcrypt would help with security, but requires a dependency on an external library.\r\n\r\nIt would seem better offhand to use the `hashlib.pbkdf2_hmac` function with a big iteration count. It is standard as of Python 3.4, and described in [Hashing Passwords in Python – Useful code](https://www.vitoshacademy.com/hashing-passwords-in-python/).\r\n\r\nSoon I hope Python will support the much better [Argon2 standard](https://github.com/p-h-c/phc-winner-argon2) for password hashing, which also allows specifying space and parallelism complexity.\r\n\r\nUntil then, users should either be warned away from hashing passwords feature, or counseled to use really great passwords.  And counseled to throw away and never reuse passwords they may have deployed in the past this way.\r\n\r\nFor more background, see [Developers, its 2019, hash password accordingly](https://markeliasen.com/developers-its-2019-hash-password-accordingly/)\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/643552006",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-643552006",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 643552006,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0MzU1MjAwNg==",
    "user": {
      "login": "nealmcb",
      "id": 119472,
      "node_id": "MDQ6VXNlcjExOTQ3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/119472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nealmcb",
      "html_url": "https://github.com/nealmcb",
      "followers_url": "https://api.github.com/users/nealmcb/followers",
      "following_url": "https://api.github.com/users/nealmcb/following{/other_user}",
      "gists_url": "https://api.github.com/users/nealmcb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nealmcb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nealmcb/subscriptions",
      "organizations_url": "https://api.github.com/users/nealmcb/orgs",
      "repos_url": "https://api.github.com/users/nealmcb/repos",
      "events_url": "https://api.github.com/users/nealmcb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nealmcb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-13T01:55:26Z",
    "updated_at": "2020-06-25T22:38:03Z",
    "author_association": "NONE",
    "body": "(...Continuing a conversation from the PR at #3793...)\r\n\r\nWith either scrypt or argon2, I guess the next question is how much memory overhead we're comfortable with. The default `memory_cost` is 105 MB (102400 KiB, from the handy `python -m argon2` command). And the parameter tuning tips at the latest IETF internet-draft on the topic \r\n\r\n* [draft-irtf-cfrg-argon2-10 - The memory-hard Argon2 password hash and proof-of-work function](https://tools.ietf.org/html/draft-irtf-cfrg-argon2-10#section-4)\r\n\r\ncurrently emphasize  maximizing memory (*3.  Figure out the maximum amount m of memory that each call can afford.*)\r\n\r\nBut the initial size of Jupyter seems more like 50 MB, based on my laptop running Ubuntu 18.04, if I'm interpreting the output of `smem` correctly. After startup that is likely to grow, but do we want logging in to always take twice the initial size?\r\n\r\nWhat is the maximum (momentary) extra memory hit you're comfortable with? I guess login most often happens at startup, but if the system is really short on memory, you'd hate to cause problems for users trying to log in to a notebook to gracefully shut it down.\r\n\r\nSo perhaps we go with a smaller value like `memory_cost=10240`, and a correspondingly higher number of iterations, like `time_cost=18` (which takes the same time per password verification as the default parameters on my machine: ~100 ms).\r\n\r\nWe could also consider different values for the maximum number of threads to use, or pick a different maximum real time.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/643648797",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-643648797",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 643648797,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY0MzY0ODc5Nw==",
    "user": {
      "login": "nealmcb",
      "id": 119472,
      "node_id": "MDQ6VXNlcjExOTQ3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/119472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nealmcb",
      "html_url": "https://github.com/nealmcb",
      "followers_url": "https://api.github.com/users/nealmcb/followers",
      "following_url": "https://api.github.com/users/nealmcb/following{/other_user}",
      "gists_url": "https://api.github.com/users/nealmcb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nealmcb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nealmcb/subscriptions",
      "organizations_url": "https://api.github.com/users/nealmcb/orgs",
      "repos_url": "https://api.github.com/users/nealmcb/repos",
      "events_url": "https://api.github.com/users/nealmcb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nealmcb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-13T16:50:50Z",
    "updated_at": "2020-06-13T16:50:50Z",
    "author_association": "NONE",
    "body": "Is any synergy with JupyterHub desired? Offhand it seems that JupyterHub can leverage authentication from either a variety of external sources as noted at [Authenticators](https://jupyterhub.readthedocs.io/en/stable/reference/authenticators.html), or from a [native user authenticator](https://github.com/jupyterhub/nativeauthenticator). The latter stores password hashes locally, generated via bcrypt with default parameters, as see at [nativeauthenticator.py](https://github.com/jupyterhub/nativeauthenticator/blob/master/nativeauthenticator/nativeauthenticator.py)\r\n\r\nThat seems to call for 2^12 bcrypt rounds, which isn't too bad according to [Recommended \\# of rounds for bcrypt \\- Information Security Stack Exchange](https://security.stackexchange.com/questions/17207/recommended-of-rounds-for-bcrypt).\r\n\r\nBut I'll note that bcrypt isn't as memory-hard (4 KiB) as argon2 or scrypt (configurable up to MB or GB), and [there is now FGPA support for bcrypt in Jack the Ripper](https://medium.com/@ScatteredSecrets/bcrypt-password-cracking-extremely-slow-not-if-you-are-using-hundreds-of-fpgas-7ae42e3272f6) (popular cracking software), which allows low-power cracking with significant speedups, if you can find suitable hardware.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/650399655",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-650399655",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 650399655,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MDM5OTY1NQ==",
    "user": {
      "login": "nealmcb",
      "id": 119472,
      "node_id": "MDQ6VXNlcjExOTQ3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/119472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nealmcb",
      "html_url": "https://github.com/nealmcb",
      "followers_url": "https://api.github.com/users/nealmcb/followers",
      "following_url": "https://api.github.com/users/nealmcb/following{/other_user}",
      "gists_url": "https://api.github.com/users/nealmcb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nealmcb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nealmcb/subscriptions",
      "organizations_url": "https://api.github.com/users/nealmcb/orgs",
      "repos_url": "https://api.github.com/users/nealmcb/repos",
      "events_url": "https://api.github.com/users/nealmcb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nealmcb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-26T21:02:22Z",
    "updated_at": "2020-06-26T21:02:22Z",
    "author_association": "NONE",
    "body": "I've reviewed the situation some more, and think the consensus continues to shift to Argon2id. So I think we should use [argon2\\-cffi · PyPI](https://pypi.org/project/argon2-cffi/) with these default parameters:\r\n\r\n    memory_cost = 10240\r\n    time_cost = 18\r\n    parallelism = 8\r\n    ph = PasswordHasher(memory_cost=memory_cost, time_cost=time_cost, parallelism=parallelism)\r\n    ph.hash(password)\r\n\r\nas discussed above. That involves using about 10 MiB of memory. Those parameters should be adjusted in future releases. See the [Django Argon2 work factor section](https://docs.djangoproject.com/en/3.0/topics/auth/passwords/#argon2) and [class Argon2PasswordHasher(BasePasswordHasher)](https://github.com/django/django/blob/master/django/contrib/auth/hashers.py#L313) for their approach, though I think making the parameters adjustable via `jupyter_notebook_config.py` would be better.\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/650414498",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-650414498",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 650414498,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MDQxNDQ5OA==",
    "user": {
      "login": "remram44",
      "id": 426784,
      "node_id": "MDQ6VXNlcjQyNjc4NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/426784?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/remram44",
      "html_url": "https://github.com/remram44",
      "followers_url": "https://api.github.com/users/remram44/followers",
      "following_url": "https://api.github.com/users/remram44/following{/other_user}",
      "gists_url": "https://api.github.com/users/remram44/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/remram44/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/remram44/subscriptions",
      "organizations_url": "https://api.github.com/users/remram44/orgs",
      "repos_url": "https://api.github.com/users/remram44/repos",
      "events_url": "https://api.github.com/users/remram44/events{/privacy}",
      "received_events_url": "https://api.github.com/users/remram44/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-26T21:37:24Z",
    "updated_at": "2020-06-26T21:37:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "I don't think we have to go with state-of-the-art crypto here. Using something that can easily be installed and won't cause issues for most users probably should be preferred. Like @takluyver, people needing stronger authentication should be using JupyterHub already.\r\n\r\nI'd just like to remind everyone that the current code is terribly insecure and can be improved at no cost, we should try to improve that soon.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/650431873",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-650431873",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 650431873,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MDQzMTg3Mw==",
    "user": {
      "login": "nealmcb",
      "id": 119472,
      "node_id": "MDQ6VXNlcjExOTQ3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/119472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nealmcb",
      "html_url": "https://github.com/nealmcb",
      "followers_url": "https://api.github.com/users/nealmcb/followers",
      "following_url": "https://api.github.com/users/nealmcb/following{/other_user}",
      "gists_url": "https://api.github.com/users/nealmcb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nealmcb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nealmcb/subscriptions",
      "organizations_url": "https://api.github.com/users/nealmcb/orgs",
      "repos_url": "https://api.github.com/users/nealmcb/repos",
      "events_url": "https://api.github.com/users/nealmcb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nealmcb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-26T22:29:45Z",
    "updated_at": "2020-06-26T22:30:46Z",
    "author_association": "NONE",
    "body": "I agree with @remram44 that the priority is addressing the very dangerous use of the current very fast SHA-1 approach.\r\n\r\nIf another dependency is ok, I think Argon2 is still the best bet.  If not, even PBKDF2 would be a huge improvement, and it is the default (with a [SHA256 hash and `iterations = 260000`](https://github.com/django/django/blame/master/django/contrib/auth/hashers.py#L247)) for that reason in Django.\r\n\r\nI don't think bcrypt is preferable to Argon2.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/650867296",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-650867296",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 650867296,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MDg2NzI5Ng==",
    "user": {
      "login": "nealmcb",
      "id": 119472,
      "node_id": "MDQ6VXNlcjExOTQ3Mg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/119472?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nealmcb",
      "html_url": "https://github.com/nealmcb",
      "followers_url": "https://api.github.com/users/nealmcb/followers",
      "following_url": "https://api.github.com/users/nealmcb/following{/other_user}",
      "gists_url": "https://api.github.com/users/nealmcb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nealmcb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nealmcb/subscriptions",
      "organizations_url": "https://api.github.com/users/nealmcb/orgs",
      "repos_url": "https://api.github.com/users/nealmcb/repos",
      "events_url": "https://api.github.com/users/nealmcb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nealmcb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-29T02:24:44Z",
    "updated_at": "2020-06-29T02:24:44Z",
    "author_association": "NONE",
    "body": "I'm curious to know how this all fits in with JupyterLab. Does it inherit whatever solution we come up with here? Or does it have yet a different way of using passwords with notebook servers?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/651038971",
    "html_url": "https://github.com/jupyter/notebook/issues/2426#issuecomment-651038971",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/2426",
    "id": 651038971,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY1MTAzODk3MQ==",
    "user": {
      "login": "blink1073",
      "id": 2096628,
      "node_id": "MDQ6VXNlcjIwOTY2Mjg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2096628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/blink1073",
      "html_url": "https://github.com/blink1073",
      "followers_url": "https://api.github.com/users/blink1073/followers",
      "following_url": "https://api.github.com/users/blink1073/following{/other_user}",
      "gists_url": "https://api.github.com/users/blink1073/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/blink1073/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/blink1073/subscriptions",
      "organizations_url": "https://api.github.com/users/blink1073/orgs",
      "repos_url": "https://api.github.com/users/blink1073/repos",
      "events_url": "https://api.github.com/users/blink1073/events{/privacy}",
      "received_events_url": "https://api.github.com/users/blink1073/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-06-29T10:12:32Z",
    "updated_at": "2020-06-29T10:12:32Z",
    "author_association": "MEMBER",
    "body": "As of today, JupyterLab uses this package as its server.  It is migrating to use the new `jupyter_server` project, so we'd have to port the change there as well.  cf https://github.com/jupyter/jupyter_server/issues/110",
    "performed_via_github_app": null
  }
]
