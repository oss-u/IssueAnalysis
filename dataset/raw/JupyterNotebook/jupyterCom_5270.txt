[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/595830160",
    "html_url": "https://github.com/jupyter/notebook/issues/5270#issuecomment-595830160",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/5270",
    "id": 595830160,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5NTgzMDE2MA==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-06T15:50:51Z",
    "updated_at": "2020-03-06T15:50:51Z",
    "author_association": "MEMBER",
    "body": "Hi @mikephd,\r\n\r\nI think this is the general nature of REPLs.  If I go into the python REPL and create a function, execute it, then change the function name, the REPL sees that as a new function, not a renamed function.  I haven't looked, but I don't think there's a way to say, \"I'm really modifying this function here.\".  Active notebook sessions should be viewed the same way, the kernel is essentially a REPL relative to its programming language.  \r\n\r\nOne thing I see is that this appears to be an issue of _scope_.  If I move my function into a class, the class becomes the outer scope.  Attempts to run the original method that has been renamed within the class result in the older method being not found.  However, if I were to change the class name, both the old and new class definitions are still \"in scope\".  Perhaps you can introduce scope, with the idea that the outer-scoped objects are subject to this behavior, while each of their methods adhere to the expected behaviors of traditional program execution?\r\n\r\nRelated to: #5263",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/596748316",
    "html_url": "https://github.com/jupyter/notebook/issues/5270#issuecomment-596748316",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/5270",
    "id": 596748316,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5Njc0ODMxNg==",
    "user": {
      "login": "mirekphd",
      "id": 36706320,
      "node_id": "MDQ6VXNlcjM2NzA2MzIw",
      "avatar_url": "https://avatars.githubusercontent.com/u/36706320?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mirekphd",
      "html_url": "https://github.com/mirekphd",
      "followers_url": "https://api.github.com/users/mirekphd/followers",
      "following_url": "https://api.github.com/users/mirekphd/following{/other_user}",
      "gists_url": "https://api.github.com/users/mirekphd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mirekphd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mirekphd/subscriptions",
      "organizations_url": "https://api.github.com/users/mirekphd/orgs",
      "repos_url": "https://api.github.com/users/mirekphd/repos",
      "events_url": "https://api.github.com/users/mirekphd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mirekphd/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-09T19:54:59Z",
    "updated_at": "2020-03-09T19:54:59Z",
    "author_association": "NONE",
    "body": "Hi @kevin-bates,\r\n\r\nI understand the root of the issue - a necessary price to pay for interactivity, for not having to import everything from the start, including large data sets at every tiny change in the code. We did try to introduce an \"alternative\" to Jupyter's REPL once (too much advertising I suppose) - VS Code (in a semi-containerized form of `cdr/code-server`, half-backed, lacking features such as upload / download for instance) and boy, wasn't it pain! While there is an extension for VS Code that allows one to run selected fragments of python code, the IDE still lacks the concept of variable persistence in an environment. So if your multi-gigabyte dataset loads from the database for some 10 minutes, at an early stage of your modeling pipeline, you would have to incur this penalty at every tiny change in your code... it quickly turns out to be impractical - REPL wins hands down.\r\n\r\nI think it would be hard to refine how REPL works without changing variables scoping in python itself. For instance one cannot prevent global scoping of variables defined outside of a function (anywhere in the notebook, even if variable gets immediately deleted). What happens sometimes is that you change a variable name inside a function, but not quite completely, you leave one orphaned occurence of the old name... A silent fail will happen if you earlier declared this variable in your global environment (during quick tests before writing proper function) and now it sits orphaned inside of the function as the only occurence and keeps being modified, yielding unexpected results (or more likely not yielding expected ones). Am I right in thinking that it is a language feature that makes it impossible to restrict access of python functions to locally defined variables, and preventing access to global ones (that may no longer exist, having been renamed)?\r\n\r\n\r\n\r\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/596758847",
    "html_url": "https://github.com/jupyter/notebook/issues/5270#issuecomment-596758847",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/5270",
    "id": 596758847,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5Njc1ODg0Nw==",
    "user": {
      "login": "kevin-bates",
      "id": 22599560,
      "node_id": "MDQ6VXNlcjIyNTk5NTYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/22599560?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevin-bates",
      "html_url": "https://github.com/kevin-bates",
      "followers_url": "https://api.github.com/users/kevin-bates/followers",
      "following_url": "https://api.github.com/users/kevin-bates/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevin-bates/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevin-bates/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevin-bates/subscriptions",
      "organizations_url": "https://api.github.com/users/kevin-bates/orgs",
      "repos_url": "https://api.github.com/users/kevin-bates/repos",
      "events_url": "https://api.github.com/users/kevin-bates/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevin-bates/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-09T20:19:15Z",
    "updated_at": "2020-03-09T20:19:15Z",
    "author_association": "MEMBER",
    "body": ">Am I right in thinking that it is a language feature that makes it impossible to restrict access of python functions to locally defined variables, and preventing access to global ones (that may no longer exist, having been renamed)?\r\n\r\nThat's my hunch, but I would _prefer to defer_ (do you like that? :smile:) to someone like @Carreau (or most anyone else) who's been working with Python much longer than myself.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/597693160",
    "html_url": "https://github.com/jupyter/notebook/issues/5270#issuecomment-597693160",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/5270",
    "id": 597693160,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU5NzY5MzE2MA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-03-11T15:15:59Z",
    "updated_at": "2020-03-11T15:15:59Z",
    "author_association": "MEMBER",
    "body": "Well I think it's not only a language issue, there is also the fact that what humans are doing is sometime ambiguous. \r\n\r\nIf you refactor a function enough, and change its name; it may be clear to the person doing so what you are trying to do, but not to the computer (or maybe even not either to another human). \r\n\r\nWe could try to treat the document as a whole and try to see which objects are defined in which cells, and when a cell change assume that the changes apply to all the object that were defined in such a cell, but it is a really narrow way of viewing things. Like if you split a cell in two, did you \"delete\" the objects ? \r\n\r\nWith the current way jupyter is working, the kernel really does not know that you have cells. Editing a cell is really just executing another input. So from the kernel POV there is no deletion or edit ever. \r\n\r\nWe could have some heuristics like with what %autoreload do; but as you both point out trying to [automatically infer the computation graph, and rerun all the cells](https://github.com/stitchfix/nodebook) can be at odds with some workflows. If there is any progress on that front from linters that would be great; but that will probably never be in the core of Jupyter to have this be an error. ",
    "performed_via_github_app": null
  }
]
