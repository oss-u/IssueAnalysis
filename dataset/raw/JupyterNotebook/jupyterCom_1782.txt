[
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249062046",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249062046",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249062046,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTA2MjA0Ng==",
    "user": {
      "login": "mej",
      "id": 2934441,
      "node_id": "MDQ6VXNlcjI5MzQ0NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2934441?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mej",
      "html_url": "https://github.com/mej",
      "followers_url": "https://api.github.com/users/mej/followers",
      "following_url": "https://api.github.com/users/mej/following{/other_user}",
      "gists_url": "https://api.github.com/users/mej/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mej/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mej/subscriptions",
      "organizations_url": "https://api.github.com/users/mej/orgs",
      "repos_url": "https://api.github.com/users/mej/repos",
      "events_url": "https://api.github.com/users/mej/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mej/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-22T23:58:39Z",
    "updated_at": "2016-09-22T23:58:39Z",
    "author_association": "NONE",
    "body": "For users with superuser access, at least on Linux, adding the option `local_lock=all` to the `/etc/fstab` file or `/sbin/mount` command line should provide relief by bypassing server-side locking and doing all locking on the client.  This should **ONLY** be done in situations where it's guaranteed with absolute certainty that only 1 client will ever write to that SQLite database at a time; otherwise, corruption **will** occur.\n\nAnother possible option is SQLite proxy locking; see https://github.com/aosm/SQLite/blob/master/Notes/ProxyLocking.txt for details.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249183546",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249183546",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249183546,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTE4MzU0Ng==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-23T12:50:51Z",
    "updated_at": "2016-09-23T12:50:51Z",
    "author_association": "MEMBER",
    "body": "Proxy locking sounds interesting. I'm reticent to invoke sqlalchemy or another ORM as a dependency for such a small thing as nbformat, especially when our SQL demands are so incredibly light.\n\nThe first thing I would look at is supporting any [dbapi2](https://www.python.org/dev/peps/pep-0249/) implementation, in which case all we should need is the right config for exposing the connection function and arguments. That should get us psycopg2 for postgres, mysql-python for mysql, etc..\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249236144",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249236144",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249236144,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTIzNjE0NA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-23T16:16:16Z",
    "updated_at": "2016-09-23T16:16:16Z",
    "author_association": "MEMBER",
    "body": "That seem reasonable. It should be pretty easy to make a swapable db manager as well. If not already possible.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249562906",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249562906",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249562906,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTU2MjkwNg==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-26T13:01:57Z",
    "updated_at": "2016-09-26T13:01:57Z",
    "author_association": "MEMBER",
    "body": "I got dbapi2 just about working, but found that even the most basic things like 'AUTOINCREMENT' aren't in common with postgres, so we would need to know what the common subset is, or deal with the relative inconsistencies. That tells me that sqlalchemy might be better, but that seems like it might be a too-heavyweight dependency.\n\nhttps://github.com/jupyter/nbformat/pull/50\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249571828",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249571828",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249571828,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTU3MTgyOA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-26T13:39:01Z",
    "updated_at": "2016-09-26T13:39:01Z",
    "author_association": "MEMBER",
    "body": "If we do want an ORM, I believe [peewee](https://pypi.python.org/pypi/peewee/2.8.3) is a lighter dependency than sqlalchemy. However, abstracting over multiple SQL databases in order to store _a set of hashes_ feels like something has gone wrong.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249579074",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249579074",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249579074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTU3OTA3NA==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-26T14:06:16Z",
    "updated_at": "2016-09-26T14:06:16Z",
    "author_association": "MEMBER",
    "body": "@takluyver agreed. If you have a better tool for looking up a hash that supports concurrent access, fast lookup without reading the whole thing in, etc., that would be great. If only SQLite+NFS weren't such a mess, I wouldn't bother putting any energy into supporting anything other than sqlite.\n\nWe also want the same thing for IPython history, where search, etc. come in. It's not actually the ORM that we want, it's just the SQL abstraction.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249614808",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249614808",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249614808,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTYxNDgwOA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-26T16:03:22Z",
    "updated_at": "2016-09-26T16:03:22Z",
    "author_association": "MEMBER",
    "body": "It seems like a key-value database would be a better fit than SQL for the signatures, though that's less clear for history. There are several embedded k-v databases, like dbm, Berkeley DB, Kyoto Cabinet. Most seem to have copyleft licenses; UnQLite is an exception, but probably has the same issues with NFS that SQLite does: https://twitter.com/unqlite_db/status/642479750368370688 . And I have no evidence that any of the other options _doesn't_ fall over with NFS.\n\nThe only embeddable thing I've found that might work is the approach used in [cdb](https://en.wikipedia.org/wiki/Cdb_%28software%29) - to add an entry, rebuild the database and rename it over the old file, relying on rename to be atomic. But our database gets big enough and changes often enough that we probably don't want to be rewriting it over NFS on every addition.\n\nSo if we can't trust the filesystem, we're back to database server to maintain consistency. I still suspect it's worth looking at key-value stores over SQL databases, but I don't have the patience to wade through all the NoSQL hype and marketing to figure out which one would actually be a good fit.\n\nDid you look into SQLite proxy locking? I had a brief skim, and it sounded relevant, but I didn't go through thoroughly enough to be sure.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/249616118",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-249616118",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 249616118,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTYxNjExOA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-09-26T16:08:01Z",
    "updated_at": "2016-09-26T16:08:01Z",
    "author_association": "MEMBER",
    "body": "(Of course, we probably need to keep an embedded option like sqlite, because I don't know of any database server we can express as a dependency, and we can't expect users to set up a separate database package)\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/252275478",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-252275478",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 252275478,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MjI3NTQ3OA==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-07T14:59:30Z",
    "updated_at": "2016-10-07T14:59:30Z",
    "author_association": "MEMBER",
    "body": "@takluyver sure. I'm mainly thinking of having a usable alternative for those on NFS systems. If there's an _easy_ option that doesn't have NFS issues, we can just pick that up, but otherwise having a decent alternative seems good enough.\n\n[simplekv](http://pythonhosted.org/simplekv/index.html) seems like an easy option for key-value store, and works on the filesystem by default, with support for memcache, redis, etc. I don't see a mechanism for the culling to trim the entries, which is the only relational bit that we do here.\n\nI'll also peek at peewee, which seems like it might be a simple solution.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/252280101",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-252280101",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 252280101,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MjI4MDEwMQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-07T15:17:01Z",
    "updated_at": "2016-10-07T15:17:01Z",
    "author_association": "MEMBER",
    "body": "Nice. Digging into the code of simplekv gives me a \"why didn't we think of that before?\" moment: its FilesystemStore creates files in a directory, named with the keys in question.\n\nThat does leave a couple of concerns, though:\n- Do we need to work on any filesystems which may have small limits on filename length?\n- Can all filesystems quickly check for the existence of a file in a directory containing thousands of files?\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/252325710",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-252325710",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 252325710,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MjMyNTcxMA==",
    "user": {
      "login": "mej",
      "id": 2934441,
      "node_id": "MDQ6VXNlcjI5MzQ0NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2934441?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mej",
      "html_url": "https://github.com/mej",
      "followers_url": "https://api.github.com/users/mej/followers",
      "following_url": "https://api.github.com/users/mej/following{/other_user}",
      "gists_url": "https://api.github.com/users/mej/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mej/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mej/subscriptions",
      "organizations_url": "https://api.github.com/users/mej/orgs",
      "repos_url": "https://api.github.com/users/mej/repos",
      "events_url": "https://api.github.com/users/mej/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mej/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-07T18:24:49Z",
    "updated_at": "2016-10-07T18:24:49Z",
    "author_association": "NONE",
    "body": "There are numerous well-documented problems on many filesystems with large numbers of files in a single directory.  (Start [here](http://serverfault.com/questions/43133/filesystem-large-number-of-files-in-a-single-directory), for example.)  The definition of \"large\" has been getting better over time, but it's still something to consider carefully.  And unless the filesystem is B-tree-based or similar, finding a file in a directory is typically a linear search (i.e., O(n)).  Fortunately, most modern filesystems are tree/hash-based by default (e.g., [ext4's dir_index](https://en.wikipedia.org/wiki/Ext4)).\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/252339355",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-252339355",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 252339355,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MjMzOTM1NQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-07T19:23:11Z",
    "updated_at": "2016-10-07T19:23:11Z",
    "author_association": "MEMBER",
    "body": "_sigh_ so we probably can't rely on that. Thanks for the info.\n\nWe could maybe write an implementation that used a nested directory structure based on chunks of a hex digest - so instead of `a49cd3...` you might have `a4/9c/d3...`. But that starts to sound complex and fiddly.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/252352265",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-252352265",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 252352265,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MjM1MjI2NQ==",
    "user": {
      "login": "mej",
      "id": 2934441,
      "node_id": "MDQ6VXNlcjI5MzQ0NDE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2934441?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mej",
      "html_url": "https://github.com/mej",
      "followers_url": "https://api.github.com/users/mej/followers",
      "following_url": "https://api.github.com/users/mej/following{/other_user}",
      "gists_url": "https://api.github.com/users/mej/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mej/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mej/subscriptions",
      "organizations_url": "https://api.github.com/users/mej/orgs",
      "repos_url": "https://api.github.com/users/mej/repos",
      "events_url": "https://api.github.com/users/mej/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mej/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-07T20:24:00Z",
    "updated_at": "2016-10-07T20:24:00Z",
    "author_association": "NONE",
    "body": "That actually isn't unreasonable.  Lots of existing stuff uses that, including Git.  :-)\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/252513072",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-252513072",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 252513072,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MjUxMzA3Mg==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-09T21:15:00Z",
    "updated_at": "2016-10-09T21:15:00Z",
    "author_association": "MEMBER",
    "body": "Culling old items seems pretty expensive without the relational part, since it seems to necessarily mean reading every file in the store (or stat if we want to use/trust mtime rather than contents). That's the only real argument I see against it right now.\n\nPip uses the same scheme (a/b/c/d/e/f123...) for its cache directory. I don't think it's too complex to deal with.\n",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/322547741",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-322547741",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 322547741,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjU0Nzc0MQ==",
    "user": {
      "login": "michaelaye",
      "id": 69774,
      "node_id": "MDQ6VXNlcjY5Nzc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69774?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelaye",
      "html_url": "https://github.com/michaelaye",
      "followers_url": "https://api.github.com/users/michaelaye/followers",
      "following_url": "https://api.github.com/users/michaelaye/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelaye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelaye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelaye/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelaye/orgs",
      "repos_url": "https://api.github.com/users/michaelaye/repos",
      "events_url": "https://api.github.com/users/michaelaye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelaye/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-15T18:23:05Z",
    "updated_at": "2017-08-16T15:48:37Z",
    "author_association": "NONE",
    "body": "Considering that https://github.com/jupyter/nbformat/pull/71 is done, isn't this done as well?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/322814895",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-322814895",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 322814895,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjgxNDg5NQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-16T15:47:52Z",
    "updated_at": "2017-08-16T15:47:52Z",
    "author_association": "MEMBER",
    "body": "Yup, depending on how you interpret this it's either done, or we've decided not to do it. Instead of using an ORM to allow different databases, we have defined the SignatureStore API, for which someone could implement a Postgres backend, or an SQLAlchemy backend, or a directory full of hashes backend, and so on.\r\n\r\nUnfortunately, we haven't found anything better to use as the default than the SQLite backend.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/322844679",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-322844679",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 322844679,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjg0NDY3OQ==",
    "user": {
      "login": "michaelaye",
      "id": 69774,
      "node_id": "MDQ6VXNlcjY5Nzc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69774?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelaye",
      "html_url": "https://github.com/michaelaye",
      "followers_url": "https://api.github.com/users/michaelaye/followers",
      "following_url": "https://api.github.com/users/michaelaye/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelaye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelaye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelaye/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelaye/orgs",
      "repos_url": "https://api.github.com/users/michaelaye/repos",
      "events_url": "https://api.github.com/users/michaelaye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelaye/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-16T17:35:15Z",
    "updated_at": "2017-08-16T17:35:15Z",
    "author_association": "NONE",
    "body": "To summarize, for my understanding:\r\n* There is a SignatureStore API\r\n* It could be used by any DB-like mechanism to create a backend that manages the signatures\r\n* the Jupyter team uses the SignatureStore API by default via SQLite which has troubles over NFS\r\n\r\nA last question: Did the team have a resource problem to implement other solutions, or is the performance overhead so large with other DBs that SQLite is technically still the best solution, despite the NFS issue?\r\n\r\nIf I am using notebooks on a shared Dropbox folder, and I would like the signature to stay valid on 2 machines accessing these notebooks subsequently (so not concurrently), would that work? I'm having especially the issue that sometimes I don't close the notebooks on one machine, and then I get SQLite clashes in the history file, but usually no other problems. But I'm afraid that these kinds of issues will create trouble as well, trying to use it for signatures, right?",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/322867664",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-322867664",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 322867664,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjg2NzY2NA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-16T18:59:55Z",
    "updated_at": "2017-08-16T18:59:55Z",
    "author_association": "MEMBER",
    "body": "> A last question: Did the team have a resource problem to implement other solutions, or is the performance overhead so large with other DBs that SQLite is technically still the best solution, despite the NFS issue?\r\n\r\nI haven't tried, but I think other DBs would be fine. I haven't implemented any because I don't have a need for them myself, and we can't realistically make them the default, because that would depend on a database server.\r\n\r\n> If I am using notebooks on a shared Dropbox folder, and I would like the signature to stay valid on 2 machines accessing these notebooks subsequently (so not concurrently), would that work?\r\n\r\nIf you go to the trouble of setting up a shared database server and configuring both notebook servers to use that, it certainly should work (it probably won't at first, because it's new ;-). I don't know how Dropbox behaves with SQLite database files.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/322875968",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-322875968",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 322875968,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjg3NTk2OA==",
    "user": {
      "login": "michaelaye",
      "id": 69774,
      "node_id": "MDQ6VXNlcjY5Nzc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/69774?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/michaelaye",
      "html_url": "https://github.com/michaelaye",
      "followers_url": "https://api.github.com/users/michaelaye/followers",
      "following_url": "https://api.github.com/users/michaelaye/following{/other_user}",
      "gists_url": "https://api.github.com/users/michaelaye/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/michaelaye/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/michaelaye/subscriptions",
      "organizations_url": "https://api.github.com/users/michaelaye/orgs",
      "repos_url": "https://api.github.com/users/michaelaye/repos",
      "events_url": "https://api.github.com/users/michaelaye/events{/privacy}",
      "received_events_url": "https://api.github.com/users/michaelaye/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-16T19:34:29Z",
    "updated_at": "2017-08-16T19:34:29Z",
    "author_association": "NONE",
    "body": "Is a database server the only way to do this? Why couldn't the notebook read a serialized dictionary for the signature? Or is that unsafe? (Pardon my ignorance).",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/322879978",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-322879978",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 322879978,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjg3OTk3OA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-08-16T19:51:45Z",
    "updated_at": "2017-08-16T19:51:45Z",
    "author_association": "MEMBER",
    "body": "A serialised dictionary written by an atexit handler would mostly work fine. The limitations are:\r\n\r\n- If the notebook server crashes, or you terminate it with a signal it doesn't handle, any signatures it has added won't be written.\r\n- If you're running more than one notebook server at once, the last one you shut down will overwrite the signatures added by the other one.\r\n\r\nThere are ways you could attempt to work around those issues, but before long you're reinventing a database.",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/jupyter/notebook/issues/comments/733294524",
    "html_url": "https://github.com/jupyter/notebook/issues/1782#issuecomment-733294524",
    "issue_url": "https://api.github.com/repos/jupyter/notebook/issues/1782",
    "id": 733294524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczMzI5NDUyNA==",
    "user": {
      "login": "jph00",
      "id": 346999,
      "node_id": "MDQ6VXNlcjM0Njk5OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/346999?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jph00",
      "html_url": "https://github.com/jph00",
      "followers_url": "https://api.github.com/users/jph00/followers",
      "following_url": "https://api.github.com/users/jph00/following{/other_user}",
      "gists_url": "https://api.github.com/users/jph00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jph00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jph00/subscriptions",
      "organizations_url": "https://api.github.com/users/jph00/orgs",
      "repos_url": "https://api.github.com/users/jph00/repos",
      "events_url": "https://api.github.com/users/jph00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jph00/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2020-11-24T23:36:07Z",
    "updated_at": "2020-11-24T23:36:07Z",
    "author_association": "NONE",
    "body": "@Carreau @willingc FYI I came to this issue because it's linked from [here](https://jupyter-notebook.readthedocs.io/en/stable/security.html) in the last paragraph, saying that changing the DB is \"currently being worked on\". However this issue is closed. So I suspect the last paragraph needs to be updated to specify what the result was, or it should link to some new issue that's open.",
    "performed_via_github_app": null
  }
]
