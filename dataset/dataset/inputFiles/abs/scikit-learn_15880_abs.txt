The signature of CODESCODES is currently: CODESCODES. The function takes an estimator and raw data and can not be used with already predicted labels. This has some downsides: If a confusion matrix should be plotted but the predictions should also be used elsewhere for example calculating accuracy score the estimation has to be performed several times. That takes longer and can result in different values if the estimator is randomized. If no estimator is available for example predictions loaded from a file the plot can not be used at all. Suggestion: allow passing predicted labels CODESCODES to CODESCODES that will be used instead of CODESCODES and CODESCODES. In my opinion the cleanest solution would be to remove the prediction step from the function and use a signature similar to that of CODESCODES, for example CODESCODES. However in order to maintain backwards compatibility, CODESCODES can be added as an optional keyword argument. TODO: Introduce the class methods for the currently existing plots:	 CODESCODES LINKLINK.	 CODESCODES LINKLINK.	 CODESCODES LINKLINK.	 CODESCODES LINKLINK.	 CODESCODES. For this one, we don't want to introduce the CODESCODES classmethod because it would not make sense, we only want CODESCODES. For all Display listed above, deprecate their corresponding CODESCODES function. We don't need to deprecate CODESCODES because it hasn't been released yet, we can just remove it. for new PRs like 17443 and 18020 we can implement the class methods right away instead of introducing a CODESCODES function. We should definitely stay backward compatible, but adding a CODESCODES keyword arg sounds reasonable to me. We should raise an error if y pred is passed but X or estimator are also passed. Would you want to submit a PR jhennrich? I submitted a PR, but I think there is currently a problem with the CI so it has not passed yet. I agree that we should support CODESCODES plot XXX y true, y pred CODESCODES to avoid calculating the prediction for multiple times. We also have similar issues in plot roc curve and plot precision recall curve. Adding y pred seems acceptable, but honestly I don't think it's a good solution. For those functions which accept kwargs for example, plot precision recall curve, seems that it's impossible to keep backward compatible? Why is it impossible to keep the backward compatibility? It seems to me that the proposal in 15883 is OK. because we do not support kwargs in plot confusion matrix. NicolasHug Why is kwargs a problem? Hmm, so there's another annoying thing, we support kwargs in plot roc curve and plot precision recall curve and plot partial dependence, but we do not support it in plot confusion matrix. if we add the new parameter before kwargs, we can keep backward compatibility, right? The changes in my PR are backwards compatible and kwargs can still be added. But I agree with qinhanmin2014, a much much cleaner solution would be to throw out CODESCODES and CODESCODES and use positional arguments y true, y pred, that are consistent with most of the other sklearn stuff. yes. Unfortunately that would require a deprecation cycle unless we make it very fast in the bugfix release but I doubt it. thomasjpfan, any reason to pass the estimator as input instead of the predictions? Thanks, let's add y pred first, kwags is another issue. This seems impossible, sigh. I agree that we need to reconsider our API design. also try to ping amueller If a user wants to provide their own plotting part and provide their own confusion matrix: CODELCODEL. This can similar be done for the other metric plotting functions. The CODESCODES is kind of designed like the scorers which are able to handle the output of estimators nicely. In other words, it is a convenience wrapper for interacting with CODESCODES and the estimator. By accepting the estimator first, there is a uniform interface for the plotting functions. For example, the CODESCODES does all the computation needed for creating the partial dependence plots and passes it to CODESCODES. A user can still create the CODESCODES themselves, but in that case it would be more invovled. Although, I am open to having a fast path, allowing for CODESCODES to be passed into the metrics related plotting functions, which will be passed directly to CODESCODES and let it deal with validation. The computation of the predictions needed to build a PDPs are quite complex. Also, these predictions are typically unusable in for example a scorer or a metric. They're only useful for plotting the PDP. So it makes sense in this case to only accept the estimator in plot partial dependence. OTOH for confusion matrix, the predictions are really just CODESCODES. I don't think we want a uniform interface here. These are 2 very different input use cases. EDIT: In addition, the tree based PDPs don't even need predictions at allThere are other things we will run into without the estimator. For example if CODESCODES were to accept CODESCODES, it will need CODESCODES because it can not be inferred anymore. In this case, I would prefer to use CODESCODES directly and have the user calculate the parameters needed to reconstruct the plot. This comes down to what kind of question we are answering with this API. The current interface revolves around evaluating an estimator, thus using the estimator as an argument. It is motivated by answering how does this trained model behave with this input data? If we accept CODESCODES, now the question becomes how does this metric behave with this data? This data may or may not be generated by a model. It's true that in this specific case, jhennrich you could directly be using the ConfusionMatrixDisplay. One drawback is that you need to specify CODESCODES since it has no default. thomasjpfan do you think we could in general provide sensible defaults for the Display objects, thus still making the direct use of the Display objects practical? For some parameters, like CODESCODES, there is a reasonable default. The other CODESCODES object parameters can have reasonable defaults as well. Some parameters must be provided tho. For example, CODESCODES must be provided for CODESCODES or CODESCODES and CODESCODES for CODESCODES. One classic pattern for this kind of thing is defining: CODELCODEL. but this is not very idiomatic to scikit learn. I start to get confused. The goal of current API is to avoid calculating for multiple times if users want to plot for multiple times, but if we accept y true and y pred, users still don't need to calculate for multiple times? I know that things are different in PDP jnothman That API is pretty nice looking! qinhanmin2014 Passing an CODESCODES or CODESCODES works in satisfying the do not calculate multiple times API. In both cases, the confusion matrix is computed and stored into the CODESCODES object. The difference between them is where the calculation of confusion matrix starts. One can think of pass CODESCODES as the precomputed value of the estimator. So I think CODESCODES y true, y pred CODESCODES is better than CODESCODES estimator, X, y CODESCODES not in PDP of course, because sometimes often? users not only want to plot the predictions, they also want to analysis the predictions. With current API, they'll need to calculate the predictions for multiple times. For metrics, I can see the preference toward using CODESCODES over CODESCODES. Imagine if the plotting for metrics support only CODESCODES. CODELCODEL. Currently the API looks like: CODELCODEL. I would prefer to have an API that supports both options somehow. Yes, this is what I mean. I think this is a practical solution. An annoying thing is that we can only add y pred at the end for example, plot confusion matrix estimator, X, y true, y pred Yup it will be at the end and the API would look like this: CODELCODEL. which I think I am okay with. This is essentially the PR LINKLINK. I guess you mean that we should add y true and remove est & X, right? I guess it's impossible? because we can only add y pred at the end Do we want to solve this in 0.22. NicolasHug thomasjfox I think it's worthwhile to put this in 0.22. but at the same time, seems that this is a new feature. No, don't put it in 0.22. it is a clear violation of semver qinhanmin2014 Adding CODESCODES at the end or removing CODESCODES seems like a new feature that belongs in the next release. In the end I would prefer to support have both interfaces, because they have slightly different use case. CODESCODES is easier to do quick analysis, because the function handles choosing the response function, slicing the result and passing it to the metric. CODESCODES is for users that understand how to work with the underlying metric and have the predictions already saved. What's the problem with doing LINKLINK? I haven't read this whole thread but if we allow the interface here, we also need to do it for CODESCODES plot roc curve CODESCODES where the interface will be quite different between providing predictions and providing the estimator one needs pos label the other doesn't. So I think allowing both in the same interface is a bad idea someone will pass pos label when passing an estimator and get a result they don't expect. CODELCODEL. Could work, but it would basically make the CODESCODES plot confusion matrix CODESCODES redundant, and so we would remove the functions again and change the responsibilities between the class and the function we said the class doesn't do the compute. If we want to add a CODESCODES from predictions CODESCODES to CODESCODES plot roc curve CODESCODES it needs to basically mirror the CODESCODES roc curve CODESCODES interface perfectly. So I don't think it's too bad to have the user call the CODESCODES roc curve CODESCODES function directly and then pass the results to the Display object. The whole purpose of the design of the display objects was to allow the usecase mentioned by jhennrich and why we separated the calculation from the function. I haven't seen an argument on why we should back down on that decision yet. amueller Technically you are right, the current solution to my Issue is to just use CODESCODES. However it is really clumsy to use: you have to pass the labels explicitly. you have to calculate the confusion matrix first. you have to create an object of the class and then still call the CODESCODES method. For all the applications I can think of a CODESCODES signature with CODESCODES would be much more convenient than what we currently have. In my opinion there are much more use cases where you want to explicitly calculate the predictions though I am sure my view is biased. If you have a CODESCODES signature and you actually want to use it on CODESCODES, CODESCODES, CODESCODES data, there is only very little additional code to write: CODESCODES. In comparison, if you have the current signature and you want to plot from CODESCODES and CODESCODES, you have to write a lot more code. In my opinion the CODESCODES signature should be default and another function that takes CODESCODES, CODESCODES, CODESCODES should be built on top. Last but not least, I honestly don't really understand the idea behind the CODESCODES class. The function only has a single constructor and exactly one method, so whenever you use it you end up creating an instance and calling the CODESCODES function. I don't see why this should be a class and not just a function. Also there are other CODESCODES classes PrecisionRecall, ROC, but their constructor and CODESCODES signatures are completely different, so they can not be swapped out anyway. Maybe this goes beyond the scope of this issue. jhennrich. For the confusion matrix case, it is simple to pass in CODESCODES if we had a CODESCODES interface. On the other hand, for CODESCODES, the user would need to do slicing: CODELCODEL. The purpose of the CODESCODES objects is to store the computed values allowing for the users to call CODESCODES many times without recomputing. This can be seen by using CODESCODES: CODELCODEL. Honestly, I am on the fence about this issue. I am +0.1 to moving toward copy the metrics interface for metrics plotting and removing the CODESCODES interface. Yes, but by doing so, we avoid calculating the prediction for multiple times though predicting is often not so expensive. Perhaps a practical solution it to support CODESCODES y true, y pred CODESCODES in plot XXX when applicable in 0.23. jhennrich How are you going to do this without passing the labels explicitly? If the labels can be inferred from what is given CODESCODES confusion matrix CODESCODES will do that for you. But indeed you're right, it's three lines instead of one. In the case of confusion matrix I tend to agree that the more common case might be passing CODESCODES y true CODESCODES and CODESCODES y pred CODESCODES. The reason the interface currently is the way it is is to be consistent with the other metric plotting functions. As thomasjpfan said, the roc curve is less obvious to plot. Right now the code for plotting a confusion matrix and plotting a roc curve are the same. With your suggested change, they won't be the same any more, and there won't be an easy way to make them the same. The question is whether in this case it's better to have consistent interfaces or to have a simple interface. jhennrich To me the real question is what the right interface for CODESCODES plot roc curve CODESCODES is. Do you have thoughts on that? thomasjpfan do you lean towards taking CODESCODES y store CODESCODES for plotting roc auc as well? There's certainly pros and cons for using the scorer interface instead of using the metric interface. But for more complex things it's much safer to use the scorer interface. qinhanmin2014. I think it would be fine to add CODESCODES y pred CODESCODES to CODESCODES plot confusion matrix CODESCODES. The question is whether we want to add CODESCODES y score CODESCODES to CODESCODES plot roc curve CODESCODES and CODESCODES plot precision recall curve CODESCODES. If we do then we also have to add CODESCODES pos label CODESCODES as I said above, and things will become more complicated. I see three ways out of this: a Only add CODESCODES y pred CODESCODES to CODESCODES plot confusion matrix CODESCODES, but don't add CODESCODES y score CODESCODES to CODESCODES plot roc curve CODESCODES etc. Downside: the problem of calling CODESCODES predict proba CODESCODES multiple times keeps existing for these metrics. b Make it easier to use the CODESCODES Display CODESCODES object directly though I don't really know how. c Add another method or function that mirrors the metric interface. Downside: bigger API surface. I don't think that having the CODESCODES plot X CODESCODES function mirror both the scorer and metric interface at the same time is a good idea in general. I think it would be great to resolve this in some way adrinjalali do you want to discuss it in the next meeting maybe? I sometimes have nightmares about this issue. Maybe we can add a static method that takes the output of the metric directly: CODELCODEL. For roc curve: CODELCODEL. On a side note, from looking at codebases, I think more users are familiar with the metrics interface than the score interface. Oh no thumbs down. I think this is definitely true. But I'm also quite certain that people use CODESCODES y pred CODESCODES when they should be using CODESCODES y score CODESCODES and are getting wrong results because the interface doesn't tell you that you need to do something different and no one ever reads the docs. I'm not sure how the static method you propose is different from the constructor but maybe I'm overlooking something. Hi, I've just up voted the issue as a long time sklearn user, I found the current API for CODESCODES very. well, confusing. I really like its addition less copy pasting, but the metrics functions always used the y true, y pred scheme which is just more flexible and what I have already been used to. In my case it doesn't make sense to pass an estimator in, as it's a very slow model and I'd rather load the predictions from a file than re run it every time I want to analyze the results. I'm happy to have found out in this thread there's a work around using the Display object, but its discoverability is not great I would suggest at least adding that to CODESCODES documentation or maybe confusion matrix user guide? Thanks for your input. If the current API is confusing, it would increasing make more sense to move to a more metrics API like interface and go through a painful deprecation cycle. The biggest concern we have with using the metrics interface is: pzelasko What are your thoughts on this matter? thomasjpfan I understand the issue, it's a tough one. Maybe a reasonable compromise would be to allow only keyword arguments for this function now that you don't have to support Python 2 anymore? Like: CODESCODES. It's still different from the rest of the metrics, but 1 it has a good reason for that, 2 it is at least using the same type of inputs as the other functions. Anyway, I know why you're hesitant to make any API changes, that's why I suggested to at least mention the work around in docs. I've actually read them numerous times and I really appreciate them! The current way to use CODESCODES and CODESCODES is shown here: LINKLINK. I know I am stretching here but what about this: CODELCODEL. where the second position accepts CODESCODES as predictions if CODESCODES. if you want to stretch even more I would prefer CODESCODES or CODESCODES but I am not sure it is solving the issues raised by amueller regarding the metric like APIThere are a few new plotting utilities where allowing a CODESCODES API would really make sense: CODESCODES in LINKLINK. CODESCODES in LINKLINK CC lucyleeow. I understand the issue that amueller mentioned about needing to pass CODESCODES etc. but this isn't an issue for any of the aforementionned functions. Are we OK to support both scorer and metrics API for these two? We don't need to worry about backward compatibility there. I am still for my suggestion of using CODESCODES, which we commonly use in our estimators. In this case, the signature would be: CODELCODEL. I'll put together PR to see what this looks like. I'm not really discussing the API yet, I'm only asking whether we're OK to support both options for new PRs. But regarding the API, I don't think 'precomputed' helps much: what do we do about CODESCODES? I think we should just keep y pred and estimator, X mutually exclusive, by properly erroring. Also what does it mean for an estimator to be precomputed? Or CODESCODES, CODESCODES, CODESCODES, and then CODESCODES becomes CODESCODES or CODESCODES. It's almost like how we handle precomputed distances with CODESCODES in estimators. How are we going to support both options? With two functions? I would have also liked: CODELCODEL. which would be two methods. Guillaume's suggestion of using tuples LINKLINK is one option. I think it would have been the best option if we had started from there from the beginning. But I'm afraid using tuples breaks consistency with the existing utilities. CODESCODES with mutual exclusion is another option, and it's the one I'm advocating for, for now. I like CODESCODES, but as Andy noted, we'd need to remove the CODESCODES functions then. It might be worth considering. I think we can move to tuples and deprecate the current behavior. As long as we agree to use tuples So this seems like discussing the namespaces, right? Whether we have one function and one constructor, or two classmethods, or two functions, it's exactly the same functionality and basically the same code. pzelasko jhennrich how do you feel about having two classmethods or two functions? Or would you prefer a single function, which is a bit messy in python. And if you prefer two functions or two classmethods, do you see any benefit despite discoverability? Discoverability might be enough of a reason to do classmethods though, I don't see a strong argument for having two functions. Could we add the blocker label here? It seems that it is preventing progress on 18020 and 17443 cc cmarmo The blocker label is for release blockers things that absolutely need to be fixed before a release, not for PR blockers Ahh good to know. I like the two classmethods approach the most, especially the CODESCODES pattern sth like thomasjpfan proposed: Looks like there's no strong opposition to using 2 class methods, so let's do that. We'll need to: Introduce the class methods for the currently existing plots:	 CODESCODES.	 CODESCODES.	 CODESCODES.	 CODESCODES.	 CODESCODES. For this one, we don't want to introduce the CODESCODES classmethod because it would not make sense, we only want CODESCODES. For all Display listed above, deprecate their corresponding CODESCODES function. We don't need to deprecate CODESCODES because it hasn't been released yet, we can just remove it. for new PRs like 17443 and 18020 we can implement the class methods right away instead of introducing a CODESCODES function. This is a bit of work but I think we can get this done before 0.24 so that 17443 and 18020 can move forward already. Any objection thomasjpfan jnothman amueller glemaitre? jhennrich pzelasko, would you be interested in submitting a PR to introduce the class methods in one of the Display objects? Thanks for making the decision NicolasHug! I'll get onto 17443 after waiting for objections I have no objections. No objection as well. I will take care of the other classes then and advance my stalled PR. lucyleeow in case I did not do all of those and you are searching for some PRs, ping me thumbs up I'd love to contribute but I'm engaged in too many projects at this time. Thanks for listening to the suggestions! Sounds good thumbs up.