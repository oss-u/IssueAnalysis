On fresh python3.6 venv, after CODESCODES and starting a new python3.6 notebook: CODELCODEL. throws: CODELCODEL. If I specify CODESCODES before CODESCODES, it works fineSame for me fresh Python 3.4 plus Jupyter, on Windows 7 32 bit. Probably related to the fact that. On Python 3, CODESCODES is always a wrapper around the CODESCODES event loop. as listed in Backwards compatibility notes of tornado LINKLINK I'm not sure at the moment what we can do about this; as the error message says, the event loop is already running, because tornado now runs on top of asyncio. What you want is essentially CODESCODES, but you can't use that outside a function. Carreau I think you were working on something related to this. Any ideas? Guess Tornado needs to use its own event loop coupled to a different thread than the one s used for the Jupyter notebook cells. Python 3.6 documentation mentions in Section 18.4 that The default policy defines context as the current thread, and manages an event loop per thread that interacts with asyncio. Maybe people have already experimented with this? I'd be inclined to figure out a way to run the user's coroutines on the existing event loop rather than starting a new thread. Threads cause all sorts of problems. Yep, LINKLINK should help, but I din't had much chance to work on it. One of the TODO items is to make it work with ipykernel and run things on the current eventloop. The framework is there it probably does not need much changes to work. Hey all, just wondering if there is there any update on this issue? I'd like to second this request for an update. As far as I am concerned, this is a major hindrance, as anything remotely useful tends to have some dosage of asyncio these daysAt the risk of stating the obvious, I'd just like to outline the following discrepency between what I get in a terminal be it python or ipython and in a notebook. I am not sure that I quite understand the other discussion there ipython ipython 10390 but regardless, it is my feeling that something is wrong at this very early point already. LINKLINK. LINKLINK. Yep, that's expected. The kernel itself runs on an event loop, and as of Tornado it's using the asyncio event loop. So the asyncio event loop is always running in the kernel. As far as I know, we haven't figured out a way to deal with this yet. but wait, as far as I am concerned this means I can't run anything tainted with asyncio in a notebook. which will asymptotically amount to saying, I can't run anything in a notebook thumbs up. it that right, or am I missing something obvious? For the moment, that's about right, though I don't think it's ever going to be the case that everything is async. We need to work out a way around it, but so far we haven't got there. Right, you can't instantiate and run an asyncio eventloop in a thread with an asyncio loop already running. You can run asyncio in a thread, as seen in 11030, which is tedious and we would like it to be unnecessary. That's going to require that we finish 10390 or similar. You can pin tornado to x while we figure this out. I'm facing the same issue while I'm trying to run some code that uses internally: CODELCODEL. Jupyter gives: CODESCODES to make min's suggestion more concrete, I could work around this issue by just issuing. pip3 install tornado 4. edit: I expect the jupyter server needs to be restarted as well You'll need to restart the kernel you don't have to restart the whole notebook server. I also discovered this because all my asyncio code stopped working after an otherwise innocuous update. For anyone else who comes across this while not quite understanding how event loops work: creating a new event loop won't help, as only one can run at any one time. Some Google bait: Spyder IPython Jupyter tornado. RuntimeError: Cannot run the event loop while another loop is running. RuntimeError: This event loop is already running. Can't kill event loopI think a possible solution workaround is to to use the ioloop of tornado, instead of running a new ioloop, but I did not get it right, any ideas? I have the same issue. the only way I was able to make it work was: CODELCODEL. heart broken parmentelat. pip3 install tornado 4.3 solved the issueAdding to this thread my idea why it might not be working correctly: In Jupyter Notebook, using Tornado 5.0 and above: CODELCODEL. Notice that the event loop has not been set up, the CODESCODES persists and remains to be the event loop of choice for the CODESCODES. In Tornado 4. when calling the last line, the CODESCODES matches the CODESCODES, ie: CODELCODEL. It is working correctly with python3. Tornado 5.1 and ipykernel 4.2 on ArchLinux by manually updating python ipykernel to the last version not working with python ipykernel 4.1 getzze. Running the code snippet in the first post of this thread with Python 3. Tornado 5.1 and ipykernel 4.2 still gives me the same RuntimeError: This event loop is already running. The real problem is imho not with jupyter or tornado, but with LINKLINK for asyncio. We are aware of the issue and working on making it easier to run async code within a notebook, without having to manipulate the event loop yourself. Getting it to work was already challenging, having it function on multiple python version is far from being easy, and we lack people willing to test our in progress pull request to give feedback. In particular on the IPython side: LINKLINK. And ipykernel side: LINKLINK. There a a lot of extremely subtle behavior, LINKLINK. Any help to do other tasks unrelated to this bug might give us some band with to focus on this, but it's relatively complex code that requires multiple hours of focused time, which is becoming rare. The new Jupyterhub has: CODELCODEL. after which I am unable to install the older version of tornado in the main environment of the Jupyterhub. Does this mean that until this issue is solved, the root main environment of any Jupyterhub 0.2 at least is broken? Carreau Those integrations look really nice, but will they be strictly optional? In other words, will there be a way to have the asyncio loop NOT running at all on Jupyter Notebook going forward? I use Jupyter as a scratchpad for development and as a developer of asyncio based apps, not being able to run CODESCODES or CODESCODES or the new CODESCODES in 3.7 from Jupyter pretty much makes it useless as a scratchpad for me. I am sticking to Python 3.6 with tornado 4.3 for now, but that clearly isn't sustainable. conda won't let me install Python 3.7 with tornado 4.3 Apologies for the short response without link, I am in a train. Multiple. things: the hub, notebook and kernels do not need to share a python installation. So it is possible to run each with a different tornado IPython version. You. just need to configure it right. Currently the Ipython kernel not the CLI needs an event loop. It. happens to be tornado asyncio. We could run with another, but that would. require some extra work. IPython tries to not run the loop when not necessary. In terminal IPython. run until complete works with no issues. In most cases you should be able to replace it in the notebook simple by.'await stuff you wish to run' if that does not fit your need can you post a. example notebook, we can work on making that simpler later on. Most asyncio packages have an entry point that deals with the loop. Asyncio itself has CODESCODES which won't work in the Ipython kernel at the moment. Aiohttp has CODESCODES. Other packages have other functions. These functions set up the loop, run the coroutines, and do application specific nontrivial teardowns of the loop. Currently, one would have to go one step lower, and reimplement these methods in the Notebook. This is not feasible. azag0 Exactly. Having the asyncio loop on the main thread always running basically breaks most asyncio based apps libraries out there. Any new comer to the asyncio world that tries to run the code of some asyncio tutorial on Jupyter will be incredibly frustrated as most sample code they find on the web which usually uses CODESCODES or CODESCODES just simply won't run. Carreau I am not familiar with the internals of ipykernel, but is it possible to have the ipykernel tornado asyncio loop running in a background thread instead of the main thread? Quick update on conda: While conda won't allow downgrading to CODESCODES on Python 3. CODELCODEL. I have confirmed overriding CODESCODES through CODESCODES does work: CODELCODEL. I am not sure if this will cause some minor bugs elsewhere or if the conda dependency check is just being overly strict though. That probably because some of the dependencies have not yet been packaged on conda. They might be compatible with Python but the conda package should be rebuilt. I see: CODELCODEL. Packaging for old Python takes time, and I guess that's were companies that rely on that could help, but it's hard to ask volunteers to do that. The other possibility is to get a contract with Anaconda and say you are looking for long term support of X, Y, Z on newer Python. As many things in open source the answer is maybe, but we also have the issues that some stuff don't like not being on the main thread. It's a matter of finding the resource to implement review maintain. I'm tempted to also say that asyncio is cooperative scheduling so these applications should give option to run on already existing loops. I understand the use case, it is just hard to figure out how to do the right thing automatically. I agree on that point. For instance, with Aiohttp, rather then the blocking CODESCODES, one can do. CODELCODEL. Ideally, all asyncio Python packages should allow such use. Unfortunately, one cannot turn a package that doesn't provide such functionality into a package that does easily. Even better, packages LINKLINK: CODELCODEL. If this was common, the current situation with the Ipython kernel wouldn't really be such an issue. We can make some old builds if they help the community and there's a good argument for that in this case. I had hoped this issue would be fixed quickly but I don't know anything about the codebase so that hope wasn't based on much! csoja should we build these packages? Well it might be a chicken or egg problem, they don't provide the functionality because users don't ask. Maybe reaching to them and saying that you need an async entry point could help. For those interested, I've just a created package called LINKLINK that solves the problem by patching asyncio to allow nested event loops. To use it in a notebook is a matter of putting. CODELCODEL. somewhere near the top. We should have prereleases of IPython 7 and ipykernel 5 next week that will enable top level async await in IPython or a notebook. Because ipykernel itself relies on asyncio, if we want to achieve the ability for users to call CODESCODES, we have just a few options: instruct users to use something like nest asyncio neat! use nest asyncio by default in ipykernel probably simplest, but I can't speak to how robust it is yet, since it seems to have only existed for a few hours. get off the mainloop, and run all of ipykernel in a background thread. We already do this for IOPub, and we could do it for the rest. Personally, I view the fact that asyncio and tornado are running to be a feature, as user code can launch long running coroutines on the main eventloop and they will keep running in the background. This would be challenging if the loop were in a thread. So my inclination is for now, recommend CODESCODES at the user level and finish shipping ipykernel 5 ipython 7 with top level await mainloop. We could even add a special exception handler for this RuntimeError to point folks at nest asyncio or autoawait: CODELCODEL. And then revisit the possibility of putting the main eventloop into a background thread at a future date. This would cause trouble for users that use a local notebook server + GUI Matplotlib backends as the GUI frameworks complain vigorously about not being on the main thread. With: Windows + Anaconda Python 3. CODESCODES solved the issue. Note: Earlier version of tornado is 5.2hi. fyi: I don't know for windows, but as far as linux, and in particular with the current ubuntu based docker stacks jupyter images, this is no longer necessary for meDowngrading CODESCODES is causing other issues for us, for example, notebooks not appearing in the home folder. And even with. CODELCODEL. CODELCODEL Running CODESCODES does not solve the problem in our case CODESCODES. Downgrading CODESCODES does: CODELCODEL I cannot say for sure, but IMHO this has more to do with the version of IPython than with the notebook. in any case and for what it's worth, I no longer need to downgrade anything with the current state of affairs, using either CODESCODES on my laptop, or using the current docker stack releases. lmeyerov Have you tried: CODELCODEL No luck. Repro: CODELCODEL. CODELCODEL. CODELCODEL lmeyerov. Override Torndado Transport Definition used in gremlin python. Tornado run sync actually starts and then stops an event loop for every call. It's not a very performant implementation. CODELCODEL. Not confirmed on the workaround yet on the competing lib, will report back. when I firstly pip install tornado 4. and secondly when I run pip install jupyter notebook. things occur to me, Installing collected packages: tornado, jupyter core, jupyter client, prometheus client, notebook, jupyter. Found existing installation: tornado 4. Uninstalling tornado 4. Successfully uninstalled tornado 4. Found existing installation: jupyter core 4. Uninstalling jupyter core 4. Successfully uninstalled jupyter core 4. Found existing installation: jupyter client 5. Uninstalling jupyter client 5. Successfully uninstalled jupyter client 5. Successfully installed jupyter thumbs down.0 jupyter client 5.4 jupyter core 4.1 notebook 6.2 prometheus client 0.1 tornado 6. how can I specify tornado 4. thanks, your solution fit me well. You can also use CODESCODES, if you go back to software releases from. within the last two years! wrote: i see this issue as closed. but seems the only solution to this is to pin versions of notebook and tornado. is that really the only solution? Thanks for the following fix lmeyerov, it allowed us to get started with using gremlinpython in a notebook. Is it still your current solution? Didn't know if you found another solution that allows using gremlinpython with a later version of notebook or ideally JupyterLab. I've tried various combinations of versions of notebook and tornado to no avail. lmeyerov did you find a solution regarding notebooks that can not be seen? minrk are there any updates here? it's been a while since this issue was closed, but this should really be open, as the workaround is very specific and is affecting us anytime we install a jupyterhub lab server, we need to pin tornado to that specific version whenever another package that uses asyncio needs to be present, and there are many more of those today. is there a separate discussion channel that we should be using to discuss this figure out a path? Hi satra I believe you meant to reference minrk. However, I'm not aware of outstanding issues remaining. While there may have been some initial instabilities in this area at the immediate 6.0 timeframe, my understanding and experience is that the tornado asyncio issues are essentially gone. I would recommend you try upgrading CODESCODES to CODESCODES or, better yet, take CODESCODES for a spin via CODESCODES. thank you kevin bates we'll try it out. ping djarecka and nicolocin kevin bates thank you for your answer, but unfortunately I'm still getting the same error CODESCODES with CODESCODES CODESCODES or CODESCODES CODESCODES. Everything works when using CODESCODES and CODESCODES. checked for py37 and py38Where are you seeing this? In the notebook server console or from within a notebook executing a cell? Please provide the output of CODESCODES. kevin bates here is the response from my environment: CODELCODEL. and the results in jupyter lab are the same error listed here: LINKLINK kevin bates: we are executing the cell with the jupyter notebook. One of the version I tested is: CODELCODEL. Your environments look fine satra, yours is slightly out of date. Have you tried adjusting your cell's code to use CODESCODES instead as bollwyvl LINKLINK? I would also suggest revisiting these two older comments: LINKLINK and LINKLINK. If you can't make any progress and given this is directly related to LINKLINK and or LINKLINK, I would suggest opening searching issues in either of those repositories where more specialized expertise resides. I had originally thought your issue was more within notebook and or kernel startup where tornado async related issues have essentially died down and apologize for not being more aware of your context. Given this is coming directly from a cell, you may need to make adjustments due to tornado's use of asyncio. Hi guys, As Kevin said, you contacted the wrong user. I think you confused way, good luck with the project. Best, Mirko D'Angelo. Mirk are there any updates here? it's been a while since this issue was closed, but this should really be open, as the workaround is very specific and is affecting us anytime we install a jupyterhub lab server, we need to pin tornado to that specific version whenever another package that uses asyncio needs to be present, and there are many more of those today. is there a separate discussion channel that we should be using to discuss this figure out a path? You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub, or unsubscribe. kevin bates we were able to update our notebooks with the CODESCODES solution and that works now on binderHi, running a function in a thread circumvents the problem as shown in here LINKLINK. In this case CODESCODES functions are inside the function CODESCODES. import concurrent. futures. def exec async func, args, kwargs: with concurrent. futures. ThreadPoolExecutor max workers 1 as executor: future executor. submit func, args, kwargs. then calling a function as. result exec async my fun, arg 1, kwarg 1 hello. idea was taken from here LINKLINK For gremlin users, gremlinpython has been fine w tornado x for awhile now. For x standard jupyter, the main technical requirement is py3.6+, but may require install gremlinpython no deps, and TBD, patching: LINKLINK I agree with satra, this issue seems like it should be open, not closed. The Python REPL and the IPython REPL work fine, jupyter notebook does not. The problem still occurs with notebook 6. riddell stan we were able to make our notebooks work by installing and inserting CODESCODES at the beginning of the notebook. CODELCODEL. see LINKLINK. it would be helpful to include this somewhere in the docs if it is indeed a universal solution. if it's not, i agree, this issue should be reopened. I understand the frustration, but this issue is not happening in the Notebook server process itself it's happening in the kernel process. Repeating my comment above: There are no code changes necessary in this repository relative to this particular issue running async code within a notebook. I understand such issues have been handled by this repository in the past. That was back when the active maintainers were also the maintainers in IPython and ipykernel. That's no longer the case and we need to be more diligent about redirecting issues to their appropriate locations. I apologize for this, and a one stop shop is always preferred, but that's the only sustainable path forward. Documentation changes, especially those that help troubleshoot issues, are always welcome. Even if this solution is not universal, there have been enough successes that make a doc update something of value. kevin bates indeed this should go over to ipykernel as the place to troubleshoot fix. it's just that for most users, they don't understand the distinctions when they use the jupyter notebook labThank you satra. I understand and completely agree. It's a very complex stack happening here, coupled with extremely varied technical levels. I have no intention of expecting folks to change how issues are reported. I just believe that redirection should happen as early in the analysis as possible and, over time, users will understand. That said, users are always welcome to start that process here and rightly so. kevin bates Thanks for the response. IPython works fine for me. The error only occurs in notebook and jupyterlab. So I gather that means it is a bug with ipykernel? Confirming that would help identify where the problem is. Also, if folks really should direct their inquires elsewhere, perhaps it would be useful to lock this and mark it as wontfix? Not necessarily the actual change could wind up being in IPython, but, yes, a deeper investigation should occur from ipykernel. I hesitate to lock the conversation because I feel that part of things can be useful to people. I have applied the 'wontfix' label however and anxiously waiting for karma come back at me on this one: smile: