Are there any estimated plans for Java api development in terms of functionality ? The only absolute choice for Java language nowadays is Deeplearning4j, any plans to occupy a niche for Java language? 
By the term "full-fledged" I mean: constructing a graph from scratch (including most common math function/operations, respectively), train CNN, test CNN, recognize the result, all of this using Java language only.
[#14094](https://github.com/tensorflow/tensorflow/pull/14094) and [#16120](https://github.com/tensorflow/tensorflow/pull/16120) is still in work and latter frozen for a few days. Just want to know your vision of future. 

P.s. need to choose right framework for starting a project at the end of June.@asimshankar Can you comment on this?any news ? If we parse the protocol buffer byte array from `TensorFlow.opList()`, will this give us a full readout of the functions we can pass to `Graph.opBuilder`? My thought is just to get a list of all available functions with inputs and outputs from `opList`, then use these to parse valid/invalid values when try to build a graph. Based on how a pre-trained graph is loaded using this Java api, it seems like this approach should work for building a graph from scratch.

I am in the same boat as you @up-to-you, and after looking through DL4J I think my preference is to stick with Tensorflow.@Nicholas-Schaub, thanks a lot, i will test this approach. Nice to have fellow in misfortune :) I hope the guys from Tensorflow will not let our boat drown in the pythonish quagmire :(

**UPDATE**

`TensorFlow.registeredOpList()` eventually delivers some operations description, but this is a painfull pain of it's translation to `opBuilder` , first of all, taking into account `Java API is not covered by the TensorFlow API stability guarantees.`

I do not have the goal of pushing this problem to Tensorflow developers, i just need information - will their automation tool for Java ops generation be ready soon or not ?
I misspoke. `TensorFlow.registeredOpList()` is the method I meant to say. I have already parsed the byte array out, and from every check I've made, it matches the Python implementation. I'm just going to make a function that builds a graph like it does in Python and checks the input values for each function against the values given from registeredOpList.@up-to-you @Nicholas-Schaub : Thanks for your interest. We haven't published a roadmap yet. So far we've been mostly interested in being able to "deploy" models typically architected in Python (often trained, but at least designed) into other languages such as Java.

The next step for the Java API is creating the op functions (#16120 is being worked on - thanks @karllessard @kbsriram ). However, we have not yet hashed out a timeline for building higher level APIs on top of that. That said, this is something that can be built on top of the lower level APIs that we do have, so if anyone wants to take a stab at it ... ðŸ‘ 

To be perfectly honest, it is unlikely that we'll have a significant change in the state of the Java API by June, but hopefully we'll have more of a plan to share by then (CC @ewilderj )
@asimshankar thanks for your information ! if I understand correctly - [#16120](https://github.com/tensorflow/tensorflow/pull/16120) will let us construct graph from scratch using Java ? If so, is there any barrier for constructing multilayered CNN ? 

Thanks in advance.@up-to-you, there are a few more pull requests upcoming after #16120 to be able to construct a multilayered CNN from scratch in Java using a rich API. 

But like @asimshankar said, even with that, there will still be some additional work to do to reach the maturity of the Python API as it contains more logic than what is exposed by the core library, shared by all the clients. For example, gradient backpropagation will still be more easier in Python than in Java (while still feasible). It would be nice if somebody could take a look at this part!Well...I'm glad I stumbled upon this. I thought that the logic for backpropagation would be in the core library, and the main hurtle was creating functions to use the core library. Looks like I'm building and training in Python and importing into Java.@Nicholas-Schaub : For now, yeah, building and training in Python and exporting to Java for inference is probably best.

Though, see the [Java samples](https://github.com/tensorflow/models/tree/master/samples/languages/java), in particular the linked slides with speaker notes, and the one trivial example of building the model in Python but actually training in Java.@karllessard @asimshankar regarding the information you provided (thanks a lot !), i think its better to emphasize efforts on model training maturity, using Java API. In this case we have advantages of both worlds : 
1. declaring model using full-fledged, short, readable Python syntax
2. training NN and inference with Java, using its performance, multithreading, big-data collaboration etc.

@asimshankar can you please provide video / source link, from where does this slides come ?The slides are linked to in the README I pointed to, but [here they are anyway](https://docs.google.com/presentation/d/e/2PACX-1vQ6DzxNTBrJo7K5P8t5_rBRGnyJoPUPBVOJR4ooHCwi4TlBFnIriFmI719rDNpcQzojqsV58aUqmBBx/pub?start=false&loop=false&delayms=3000)

They were from a talk I gave in a Java Users Group meeting. I don't think there is a video link.Just to add something about this: other than the ubiquitous differences between the two languages, what is really interesting about having a Java graph building API compared to Python is the way it enforces tensor type checking at compile time (by using generics). So you know exactly what datatype you are dealing with at the output of an operation and what you can possibly do with it. So I think current efforts are not done in vain... or at least I hope ;)

Implementing the core ops in Java is a big step forward for having a mature client library and yes @Nicholas-Schaub, it will be possible to do backpropagation using the [training ops](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/ops/training_ops.cc), for example. But it will not be as easy as in Python until we figure out how to extract and expose the logic implemented in its client library, like its [gradient descent optimizer](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/training/gradient_descent.py).@karllessard If the issue is just figuring out how to expose the logic, isn't it just a matter of parsing the `registeredOpList' to get a list of functions and their inputs/outputs and writing a rudimentary translator to make sure that the appropriate inputs and outputs are being sent/received? The way it was discussed above, I thought that we would have to implement the gradient descent optimizer. My approach was just to parse the op list and write a generic graph building class that shows which operations are available and what inputs/attributes are needed. If the gradient descent functions are implemented in the core library, then it seems like it's just a matter of then building a simple class to cycle through layers for backpropagation. The hardest part for me seemed like it was going to be parsing the operations list, and then I could build a couple simple classes to build and train.My thought in implementing this wouldn't be something quite as nice as what Python currently has, but it would be enough to build a graph and train it. During the graph building phase, the individual elements would be added to a JSON string, and then the graph could be built based off the JSON string and checked for errors using the info we get from parsing the op list.@Nicholas-Schaub 

> isn't it just a matter of parsing the `registeredOpList`...

It is a bit more tricky than that. The `registeredOpList` does not provides all the required information to classify the ops properly (for instance, their "group"). This is why it has been decided to import them from a C++ process instead, that links to the individual libraries and generates Java classes for their ops at compile-time. PR #16120 and those upcoming are about this.

Just if you are curious, you might find a snapshot of the ops I have generated (and never tested) a long time ago from a intermediate version of this generator [here](https://github.com/karllessard/tensorflow/tree/java-ops-samples/tensorflow/java/src/main/java/org/tensorflow/op).Does the grouping matter? I thought having the necessary information to build a function using `Graph.opBuilder` would have been enough. It seems like this is how the current state of the java side of things imports pretrained networks. Is there ambiguity in function handles between the different groupings? Why isn't having the names of all functions with corresponding inputs and attributes sufficient to use the opBuilder?

I apologize for drawing out the conversation, but it's been incredibly helpful thus far. Thank you for the link.> Does the grouping matter? 

Grouping doesn't matter at the functional level but it does matter at the API level. By this I mean that if you want to list and create classes just parsing the `registeredOpList`, it will work but you'll endup with a single package (group) of 600 classes or so, which would not be usable/acceptable as an official API for Tensorflow (just think how the auto-complete feature of popular IDEs will react on this). But for personal use, yes that'll do.

> I apologize for drawing out the conversation, but it's been incredibly helpful thus far.

No problem it's a real pleasure, we can continue that discussion on a more private channel if you are interested, by joining [this group](https://groups.google.com/forum/#!forum/tensorflow-java-dev-unofficial).@karllessard can you please shed some light on other pull requests planned after [#16120](https://github.com/tensorflow/tensorflow/pull/16120) which will allow to construct multilayered CNN ? I'm gonna make some performance benchmarks in comparison to python impl's, since training elapsed time depends not only on C++/CUDA implementation, but on fetching and treatment of data too (before feeding it to CNN). And I make big bets, that in this part of whole process, Java will surpass Pythonish approach.

P.s. it will be more clearly for results if whole NN lifecycle will be build using Java. Just for some reflection on an abstract level [Python vs Java benchmarks](https://benchmarksgame.alioth.debian.org/u64q/python.html)@up-to-you : FYI: if you use the [`tf.data` APIs](https://www.tensorflow.org/programmers_guide/datasets) to feed data to your model, then all the data is read, processed, and fed by the TensorFlow runtime, so the frontend language is unlikely to be a bottleneck. Long story short,  it will generally be possible to get the same performance irrespective of frontend language.@up-to-you : very interesting, indeed. Asim brought an interesting point with the `tf.data` APIs but it would still be very nice to benchmark the performances of the Java client independently on this.

Timewise, #16120 has been accepted and is just waiting to be merged. After this, the target is that I come up with another PR by the end of the month which will actually generates the Op classes in the `libtensorflow` jar. 

From there, you'll be able to build a graph in Java using those classes. More PR(s) will still come after to wrap those classes with a builder-like API but functionally, they should be ready to be used directly.BTW, it's already possible to use the full C and C++ APIs with the [JavaCPP Presets for TensorFlow](https://github.com/bytedeco/javacpp-presets/tree/master/tensorflow), and we can pretty much do anything we want with that including building graphs and accessing the ops, for example: 
https://tebesu.github.io/posts/Training-a-TensorFlow-graph-in-C++-API
https://matrices.io/training-a-deep-neural-network-using-only-tensorflow-c/

If there is anything missing from the bindings though, it should be a simple matter to add, so please do let me know! I'm very interested in making C++ libraries usable from Java and in understanding what is lacking, the difficulties, etc. So any feedback is welcome! Thanks@saudet, First of all, its awesome, really!
But, as @karllessard  mentioned - there are a lot of logic, implemented at python level. For example i can't find api, that allows to write something like this:

`l1 = tf.layers.dense(x, L1, activation = tf.nn.relu, use_bias = True )`
`l2 = tf.layers.dense(l1, L2, activation = tf.nn.relu , use_bias = True )`
`...`

and, honestly, unfortunately, i don't know how to implement same logic, using existing Java api in Tensorflow project, nor in your bindings.Thanks! Yes, I am aware a lot is implemented only in Python, but at some
point it needs to be implemented in either C++ or in Java. Imagine it gets
implemented in a user-friendly API in C++, what would make you not use
JavaCPP? What would still be missing? That's the kind of feedback I'm
looking for. :)
I'm glad I've held off working on making up my own solution to this problem since it sounds like things are starting to come down the pipe.

@saudet What would make me not use JavaCPP is that I need to do things in native Java. If it's included in a dll that's fine, otherwise it's a headache.@saudet, JavaCPP is a very interesting project indeed, but I think for tensorflow, Python client will always be a step ahead of both Java and C++ clients for training.

@kbsriram already thought of doing the same thing but with a PythonToJava flavour, I donâ€™t know what would be the complexity of such work though.@Nicholas-Schaub IMO, we're far from getting everything in place, so please keep looking at things! What bothers me though is that I had mapped the C++ API of TensorFlow API way back in 2015, but apparently this was not a satisfactory solution for Google (and I am still looking for an explanation as to why that is) and their engineers (mainly @asimshankar) started writing JNI code manually and building a custom API on top of that. I can see this is still in progress, first to match the functionality of the C++ API for the ops, and then eventually of the Python API.

So, anyway, all that to say, I would welcome any feedback about JavaCPP and what's missing. I mean, I do receive feedback from users saying that the C++ API isn't user-friendly, which is fair enough, but then why not build a user-friendly API on top of automatically generated wrappers like they've been doing for the Python API with SWIG? Why is there a need to write everything manually down to all the JNI functions?

@karllessard Yes, I've also been talking about that, and https://jyni.org/ is another project which could use our support and that could provide that. They've got NumPy running, adding TensorFlow would probably not be that hard, if we can actually get 1 or 2 engineers working on that full time that is. Again, it won't provide a Java-friendly API out of the box, but it would take care of generating all the nasty boilerplate code, so why not use, if not that exactly, something like that, at least?Wow, it seems like [#14094](https://github.com/tensorflow/tensorflow/pull/14094) merged, i'm staying tuned on next pull requests ! @karllessard @asimshankar thanks guys !@saudet: Regarding ["I'm still looking for an explanation as to why that is"](https://github.com/tensorflow/tensorflow/issues/17390#issuecomment-375837293), I didn't know that you had ever asked for one :). My apologies if I missed some previous comment asking about this.

First some background:
- TensorFlow has a runtime implemented in C++, but for "frontends" we provide a smaller C API surface in [c_api.h](https://www.github.com/tensorflow/tensorflow/blob/master/tensorflow/c/c_api.h). Unlike the C++ interfaces used in the runtime's implementation, we do provide API stability guarantees for the C API.
- This stable C API surface makes it suitable for implementing most language bindings. The Python frontend connects to the runtime via this C API, as do the other languages like Go, Haskell, Rust, Ruby etc. (In Python's case, this C API is what is SWIGed)

The Java API implementation in this repository has a relatively small hand-written JNI wrapper over the C API for the lowest level constructs (Graph, Operation, Session). The work by @karllessard and others is not adding any additional JNI, but generating idiomatic pure-Java wrappers for all the TensorFlow operations by  composing the lower level Java constructs. This is again very similar to how the Python API wrappers (`tf.add`, `tf.gather` etc.) are generated to use the Python constructs built on top of the C API. The same for Go. These language-specific generation tools make it easier to generate code that follow idioms of the target language. For example, in Java, generics are used to indicate the element-type of `Tensor` objects. It's a small amount of JNI to build the lowest level constructs and then a generator of pure Java code on top of that. It's not that "everything" is being written in JNI manually.

Long story short, there were a few options we had:
- Write a small amount of JNI over a stable C API and generators for higher level APIs on top of it.
- Use tools like JavaCPP or SWIG or  [CLIF](https://github.com/google/clif/blob/master/clif/python/faq.md#q-what-about-interfacing-c-with-languages-other-than-python-such-as-java-and-go) to generate a Java interface from the C++ API.
- Use tools like jyni to generate from the Python API.

Each of them is attractive and has pros and cons. It was useful for us to have a Java API, particularly for executing models. In our judgement - given needs, the resources we have, and the fact that the API in this repository is something we (the TensorFlow team) support and maintain, the simplicity of the first approach - with fewer layers of abstraction, a small set of core constructs (backed by native code) upon which richer idiomatic APIs can be generated or built (in pure Java)  made it appropriate.

I appreciate that there is some subjectivity involved in such a choice and that reasonable people can differ. However, I hope this at least provides a sense of where we were coming from. Looking ahead, we're figuring out the best way to get more community involvement in Java development, I'll be sure to reach out once we've figured out an appropriate forum for that. At that point, we can have a more detailed discussion (and possibly revisit these choices).

Also, your point about the C++ API not being user-friendly enough is well taken. Making graph construction APIs in C++ easier to use/navigate would be great, but is not currently on the top of our priority list.
@asimshankar Thank you for the thorough explanation and for clarifying the discussions that have been happening offline! My opinion though is that it is possible to design a C++ API that can be mapped automatically to other languages in a satisfactory manner. OpenCV is an example that is pretty close to that, and JavaCPP maps it pretty well. There are rough edges, but this is only because Java and Python are an afterthought of the C++ API. Given a bit more planning though, we could save many hours that are currently spent developing and maintaining essentially the same library in different languages. JavaCPP wraps only for Java, obviously, but there are no reasons why the same couldn't be done for other platforms. This is out of scope for TensorFlow, but it would be nice if we as a community could start developing more processes and tools like this to save time and effort. CLIF looks like an attempt at that, but I am unaware of anything significant actually using it...?

In any case, for now, I've bundled the official Java API in the JavaCPP Presets for TensorFlow:
https://github.com/bytedeco/javacpp-presets/tree/master/tensorflow#documentation
This will make it easy for anyone to start with that API, but "upgrade" to the C++ API to access functionality only available there--without any build time or runtime conflict. If you ever need help integrating this into the Bazel build or anything, please let me know!@asimshankar I talked to rajat about this a few weeks ago and he actually encouraged collaboration.@saudet has done a ton of optimizations on the c++ side already (esp lower level pointer math with zero copy buffers rather than the manual copying that happens with the current java API) - we use those same optimizations in depth with our tensor library as well. If you don't mind I'm going to follow up directly again with him showing him this issue. We're trying to play ball here if we can. We are likely one of the few entities outside of google interested in making this work well. I'd like to see if we can open this up a bit.@agibsonccc : Certainly, please do follow up. Those optimizations sound great, and we'd love to leverage expertise here. The details of how to do so would be worth working out, and having some off thread conversations before settling on something and updating this issue sounds great to me.Perfect. Just wanted to start a dialog. Someone reached out already.  Will keep folks posted on concrete outcomes, thanks for the interest!Just FYI everyone, pull request #18192 has been created to generate the Java operators and it is a big step forward to have full-fledged support for TF graph building in Java. The PR is quite big and it might take some time before we get it merged but we'll do our best, thanks!@karllessard , I want to do the graphbuilding using static functions(until tf rolls out the generated APIs), similar to what you have in the LabelImage example. It would be a complete training example with ops for both objective and say gradient descent. Since Java does not implement the autodiff functionality that python has, can you suggest any simple way of doing this (or do you have any POCs like the Labelimage one?). @asimshankar Great! Looking forward to the discussions.

FWIW, TensorRT has a nice C++ API and JavaCPP maps it pretty well too:
https://github.com/bytedeco/javacpp-presets/tree/master/tensorrt
I'm not saying TensorFlow needs a C++ API though. I suppose tools for other platforms should catch up before it makes sense...@himsR , either with the upcoming Ops API wrappers or with current `OperationBuilder` & friends, the only thing that is supported in Java for building a graph is by using TensorFlow core operations. Anything else needs to be ported to the clients of each languages at some point (e.g. the C++ client has already started to port some of the Python functionalities). 

I guess supporting those features will be the next step for the Java client, now that the `Op` wrappers are almost there. Right now, its improvement mainly relies on contributions so I suggest that you go on with building your graph, identify what is missing in your case and share it with us... or even better, write it down and submit your code :)

@karllessard thanks for the information. The op wrappers that you are writing , do they include the gradient ops as well? For example , something equivalent to the ops inside the math_grad.cc in the core ? @himsR : are you talking about `math_grad.cc` of the C++ client? If so, most of those ops come from the `math_ops` library so yes, they will be wrapped. The current scope for the first draft of wrappers is to cover the following libraries (that could be found [here](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/ops))
```
array_ops
candidate_sampling_ops
control_flow_ops
data_flow_ops
image_ops
io_ops
linalg_ops
logging_ops
math_ops
nn_ops
no_op
parsing_ops
random_ops
sparse_ops
state_ops
string_ops
training_ops
user_ops
```@karllessard yes that's awesome. Since the above list does not include the gradient files, it would still be required to code all the gradients using ops from these apis.  So yeah this should give all the ops required to build the backpropagation logic into java. I asked particularly about the gradients because I think at present client languages like python impelement all the gradients themselves(by calling and combining the normal ops) instead of calling the c core. So at present in Java, although you can call all the ops using the 'OperationBuilder' but you can't get the gradients that way. Thanks.Hey, @karllessard, I have a question for you. I see from your pull requests #14094, #15928, #16120 and #18192 that you had to write almost everything in C++, but with JavaCPP, it would have been possible to do it all in Java. Had you been given the chance to do it in Java instead of C++, do you think it would have made things easier for you?In any case, my point is that if we could offer developers the option of contributing code in Java instead of having them write most of the plumbing in C++, TensorFlow would get a much wider adoption from the Java community. Many Python developers can also write code in C++, but this is not typically the case of Java developers.

It's also one of the big differences between SWIG and JavaCPP. With SWIG, developers are forced to code in both C++ and the "scripting language" (Python, Java, etc). Instead, JavaCPP maps the C++ API wholesale, offering a complete and usable Java interface, without any need to write or make adjustments to the C++ code. BTW, if anyone knows of an alternative to access the full C++ API of TensorFlow from Java (or from any other platform for that matter, in C#, Go, Rust, JavaScript, etc), please let me know: I would welcome competition! :)Hi @saudet, sorry for the delay. I feel that there might be a little bit of misunderstanding here, please let me explain more in details. Sorry for the novel ;)

> Had you been given the chance to do it in Java instead of C++, do you think it would have made things easier for you

Definitely, a challenge I had in C++ was to output Java source code efficiently, which could have been provided out-of-the-box from Java frameworks, such as JavaPoet.

The main reason why I had to go with C++ the generator the operation wrappers, as I told @Nicholas-Schaub previously in this thread, is to benefit from operation classification which, at that time, could only be achieved by only linking one core op library at a time to the generator binary and use that library as a package delimiter.  Otherwise you'll end up having all 700+ ops in the same package, which is not convenient. That's the approach the C++ client was taking too. It was a bit hacky, in my opinion, but I'm not sure to see how JavaCPP would have help me doing otherwise here. 

On this topic though, there have been some updates to this issue. Lately, the TF community has introduced a new layer of abstraction over the core ops definitions, called `Api defs`, which not only exposes classification information in proto buffers but also allows variation of the API per language for fine-tuning. With this new API framework, the wrapper generator could have been written in Java from the start. Now that there is only #18192 remaining to generator those wrappers, I guess we should continue in the current direction and maybe migrate that code to Java later.

 > if we could offer developers the option of contributing code in Java instead of having them write most of the plumbing in C++

And that is actually already the case. Once the wrappers are available, any addition or "plumbing" to the Java client could be written directly in Java. There might be a bit of JNI code to do here and there I guess, but features I can think so far shouldn't require it.

From what I understand, JavaCPP goal is to simplify access to native libraries without the need of writing JNI code by ourself or interfacing with proto buffers, is that right? So your idea is to have a fully-compliant C++ client that could be "wrapped" in Java as a replacement of the actual client or is it just to replace the JNI bridge? I have no doubt JavaCPP is more convenient that writing JNI code. Proto buffers, on the other hand, is easy to support. Also, how JavaCPP would it handle features that are unique to the Java, such as generics, Javadoc, etc.? IMHO, what really matters in the end is the quality of the interface exposed to the user and not how it was developed.@karllessard Thanks for the insights! Unless the C++ API is designed in a way to let us generate automatically nice high-level APIs, there will always be a need to develop something on top. I agree with that. 

I'm not familiar enough with TensorFlow to evaluate how much work there is still to be done with the C++ API to get the Java API to be as feature complete as the Python API, but looking at the amount of code that the SWIG interface files from TensorFlow generate (about 25000 lines), I'm guessing "a lot". Am I wrong?

JavaCPP basically provides access to everything C++. JNI is completely abstracted away, so the fact that it uses JNI isn't really relevant. Any other approach that I am aware of forces developers to get their hands dirty with C++. They don't offer a way to just use it from another language such as Java--with full support for reflection--whether it's one big API, or a bunch of smaller ones in "groups" (of operations, etc), which I call "presets": http://bytedeco.org/.

There is a Java API for protocol buffers, so that should be used whenever possible, sure. I'm not saying that using wrappers around C++ generated code is a better idea. :) Anyway, the concept of using C++ classes and templates from another language isn't new, but it's a road paved with failures and very limited success that has made many casualties over the decades, so it's hard to get people to even acknowledge that it's actually possible...@karllessard can we expect tf.train.Example, tf.python_io.TFRecordWriter, tf.train.Feature and other tf.train.* types wrappers? This impl will blow up everyone, since it will shut the hole in Spark <-> Tensorflow integration. Until higher level api will be implemented in java.Hi @up-to-you , what is being ported right now are core ops that can be added to a neural network for training, i.e. most of the ops that are registered [here](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/ops).

AFAIK, what you are referring to are utilities to store example data that happens outside the network, so it won't be part of the current work (though you'll be able to read data stored in a `TFRecord` from the network using the `TFRecordReader` core op).

Good news is that nothing prevent a programmer to add `Example` & friends support right now in the Java client, I guess it is just a matter of creating a proto message from data provided in input. Some utilities though might require a pinch of JNI bindings (or what @saudet is currently proposing).@karllessard I'll try my best in this way, but can you please provide some food for thought or some direction where i can start. Thanks in advance!
P.s. e.g. can't find any information about in-depth proto-structure of TFRecord file.
@up-to-you : Well, I haven't look too deeply in the Python code but it looks like it's invoking the core utility [`RecordWriter`](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/lib/io/record_writer.h) to accomplish the task of writing data. We should probably do the same by writing a new [JNI binding](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/java/src/main/native) for it.

Then, for supporting the `Example` format, I guess we could generate classes out of the [protocol messages](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/example/example.proto) using a [`java_proto_library` rule](https://github.com/google/protobuf/blob/master/examples/BUILD) and maybe wrap their usage in a `ExampleBuilder` object? @up-to-you: `tf.train.Example` is available in the [`org.tensorflow:proto`](http://mvnrepository.com/artifact/org.tensorflow/proto) maven artifact (see [javadoc](http://static.javadoc.io/org.tensorflow/proto/1.7.0/org/tensorflow/example/Example.html)). That artifact contains all the TensorFlow protocol buffers for Java.

It would be great to work out a path to include full functionality by leveraging the best of @karllessard and @saudet 's work (and effectively utilizing JavaCPP). But we haven't gotten around to figuring out the details of that yet. 

Perhaps you're willing to pioneer a first exploration towards that by updating the JavaCPP presets for TensorFlow so that it can provide a Java interface to the C++ [`RecordWriter`](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/lib/io/record_writer.h) class?@asimshankar @karllessard Sounds like the perfect opportunity to try this out with JavaCPP! Thanks

@up-to-you I've updated the presets with `RecordWriter` in commit https://github.com/bytedeco/javacpp-presets/commit/e64724b5d194affeebf4c2934c0c4c557f3111ea. New snapshots should be available in a few hours: http://bytedeco.org/builds/
And a sample pom.xml file is available at:
https://github.com/bytedeco/javacpp-presets/tree/master/tensorflow#sample-usage
Let me know if you encounter any issues with that or have any questions. If this works well, I'm assuming we would next have to integrate JavaCPP into the Bazel build, and probably start small and/or somehow modularize the API, something I'm happy to help with!@up-to-you While we're at it, I've also included `feature.pb.h`, `example.pb.h`, `record_reader.h` in commit https://github.com/bytedeco/javacpp-presets/commit/fce6bfb26ceacb8d7a4cd4ed6651e0f1e1ffc8ac. FYI, while the Java API of protocol buffers are easier to use, serializing and deserializing with the C++ versions might be be faster, especially if the resulting objects are to be used with the C++ API anyway.Thanks @saudet, but AFAIK, that shouldn't be required in our case, the `Example` protos are just used to define a standard format to a binary file and are not used for transportation, the data is passed as a simple byte array to `TFRecordWriter`. 

As of serializing/deserializing those messages in the Java client, I think we can opt for simplicity over performances here. The way I see it that we should use as much as possible vanilla-Java code in our solution and rely on JavaCPP only when required, what do you guys think?

(Just FYI, I talked @ewilderj and there is a possibility for us to have a official community platform regarding Java development in TF for discussions like these, if you are interested!)You're referring to premature optimization? Yes, of course, I agree.
Hi, it seems that https://github.com/tensorflow/tensorflow/pull/18192 is merged so can we expect a Maven repository and some tutorials to make graphs anytime soon?Hi @arnaghizadeh , even if #18192 has been commited and that you can build a graph out of it, the work is still in progress and only curious developers should make use of those wrappers right now. To have a fully-compliant graph building API, there is two more tasks to be completed:
1. Generate the API classes that exposes those wrappers in a builder fashion. This is what will allow you to write clean code like
```java
ops.add(ops.unique(s, Long.class).y(), ops.constant(4));
```
where right now, you'll need to do something more verbose like
```java
Add.create(scope, Unique.create(scope, x, Long.class).y(), Constant.create(scope, 4));
```
I was working on that PR last week and it is now ready to be reviewed (#19309)

2. Categorise the generated operations wrappers. Right now, all ~800 wrappers are output under the same package, which makes it hard to use, I find. I'll check with @asimshankar how they should be divided into groups but the end goal is to have something like:
```java
ops.math().add(ops.array().unique(s, Long.class).y(), ops.constant(4));
```
When those two tasks will be completed, I'll write down an example on how to use the new API, thanks for your patience!@karllessard thank you can't wait to create graphs in Java. By the way, have you guys been in touch with Swift for Tensorflow group and specifically Chris Lattner? The cleanness of their code is simply out of this world. My understanding is that they are changing the language itself and that's why they can achieve that kind of cleanness and ease of use, so possibly this is not feasible in Java. But maybe there are still some hope and long term plans to have something similar in Java or even with Kotlin which is probably more open to change the core language?@arnaghizadeh No, I didnâ€™t look at the Swift implementation but I will, thanks for the tip!

For the Java part, I also believe that Kotlin is the way to go these days for a simplified version of the language, so Iâ€™ll make sure we take all advantages of it in the API we are building. Please let me know if you have any specific idea in mind about this.@karllessard From my limited understanding, what they are doing is that they have integrated Tensorflow eager mode with the swift compiler so there is no need to create graphs, the graphs are created by compiler itself. The end result is a very natural integration of Tensorflow with Swift language which is much more pleasant to work with than what we have in python. Even with its eager mode, the Tensorflow of python does not seem to be a match with this design. From what I could tell, they also provided a better version of the Numpy (with Tensors) for the swift language in a natural way. If next to the API that you are working on, something like this can be implemented for e.g., Kotlin that will be a blast.@arnaghizadeh : Speaking on behalf of the TensorFlow maintainers: Yes TensorFlow for Swift seems like a very promising avenue which is why we are pursuing it. There is some discussion on the approach described there working for Java in [the whitepapers](https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md#which-languages-fit-our-project-requirements).

That said, this is still a very early stage project with lots of technical details to work though and for now there are no plans to investigate this approach for Java/Kotlin (at least by the TensorFlow maintainers).Hi TensorFlow maintainers, Thanks for a great project!
`TensorRT` has been integrated into TF since `r1.7`. How can we use this in java for inference phase?@asimshankar @karllessard For reference, with the new additions to the Java API, is it now possible to build a graph for training like this? 
https://github.com/bytedeco/javacpp-presets/blob/master/tensorflow/samples/src/main/java/org/bytedeco/javacpp/samples/tensorflow/CarPricePredictionExample.java@saudet: yes, with the addition of supporting features that are unique to Java

For instance, using generics, you can keep track of the datatype of your tensors as you build your graph and get notified at compile time (or a edit time within your IDE) of any operation that is not allowed. For example, using Kotlin:
```kotlin
val x = ops.placeholder(Float::class.java)
val y = ops.placeholder(Float::class.java)
val z = ops.placeholder(Long::class.java)
ops.matmul(x, y) // compiles
ops.matmul(x, z) // does not compile
```
I'm waiting for PR #19309 to be merged and for instructions from @asimshankar on how operations will be grouped into packages, then we'll be able to write some more examples.Yes, that's cool, but I was mainly wondering about the gradients for training. It sounds like that would require some JNI... I guess I'll wait for the examples :)Are there any ways to migrate missing functionality from @saudet CPP to @karllesard solution ?
**P.s.** i think its more difficult to migrate vise versa@up-to-you The plan is to integrate JavaCPP in the Bazel build, but for now we can still use the Maven build. At this moment though, as far as I know (given that I didn't get any reply from @karllessard or @asimshankar  about this) I am assuming there is no integration with the Java API for the ops with C++ functions like `AddSymbolicGradients()`, so work other than on the build also needs to be done before we can use both APIs together. No need to do everything by yourself though. You could work on the integration, get that working, and someone else could work on the build in parallel, or vice versa. In any case, if you are interested in working on this, but are encounter issues, please post your questions so that we can help. Thanks!Hi guys, please let me reiterate my thoughts on this.

I think JavaCPP can be a useful addition to the current Java client but I would keep its usage internal. It perfectly fits as a replacement to the actual JNI bridge, being more flexible and probably more performant. But I would stick to a thin layer of pure-Java for classes that are exposed publicly, so we can easily introduce Java-specific features, like generics, and have more control over the API in general.

That being said, I don't want to sound dramatic but I think that open-source development is all about collaboration and not competition. Competition is a complete no-fit. Our goal is to develop the best Java client for TensorFlow, no matter how, and we should merge all of our efforts towards this end only. @saudet, if you can't agree with this, then I don't think I can help you much here. BTW, you say that you get no reply from me but I can't recall or find any question or request from you.@karllessard Don't worry, I agree. I asked about how we could build a graph for training, but I did not get a reply, so I simply assumed it wasn't possible. If this is not the case, please say so! I'm merely trying to make it clear what is possible and what isn't, what needs to get done, etc. I am always trying to find ways to communicate in a more friendly way, but I admit it is not easy for me, as I simply get ignored if I don't "push" a little.@saudet : Regarding adding symbolic gradients in the Java API, we'd have to add a Java function corresponding to [`TF_AddGradients`](https://github.com/tensorflow/tensorflow/blob/65c05bc2ac19f51f7027e66350bc71652662125c/tensorflow/c/c_api.h#L1127). So, you're right it doesn't exist yet, but should be easy to add as a method on `Graph`.@asimshankar : actually writing down an Mnist example in Java, I already ended up with the need to implement the JNI binding for `TF_AddGradients` in `Graph`. Another PR ready to get in line for you ;)

@saudet : Glad to hear that! Then, I think we can start to discuss on how you could help contributing. I really think we need another communication channel than this thread to synchronize everybody's efforts. I suggest we use this [unofficial group](https://groups.google.com/forum/#!forum/tensorflow-java-dev-unofficial) for now until Google can setup something for us (and I invite everybody in this thread to join it). And maybe we can have a separate branch to consolidate our work, ideally in TF repo? @ewilderj , can you help us with all of this?

Thanks@asimshankar @karllessard Well, it's not just about me contributing, it's also about changing _your_ frame of mind. You keep writing everything in C++ and JNI manually, why? You have to understand this doesn't look attractive to Java developers. Could we start by making a list of what's missing from JavaCPP? Is it just the Bazel build for now or is there something else that I should look at first?

@karllessard I've applied to join your group. Thanks! As for a branch, if you keep your fork up to date, I think we can just all use that for now as well.@saudet : At a high level, I feel that the **primary focus** should be on creating the right API to **use** TensorFlow from Java. The details of how that API is _implemented_ (JavaCPP, manual JNI, C++ or Java code generator etc.) is secondary, and changeable. The "right" API is characterized by appropriate abstractions that are easy to understand for a Java developer, a thoughtful exposure of features, and performance.

If we agree on that (that the experience of the API user is paramount) then we can have a productive conversation on the implementation details. I don't believe we should be working the other way around (i.e., being driven by what's easy to implement). 

With regards to what's missing in JavaCPP - I don't have a list handy, and maybe nothing is missing. Honestly, I haven't devoted enough time to thinking through the details of what switching to JavaCPP would entail. Which is where contributions can help. Since you're passionate about this, perhaps you could do that? Some things to think about in a concrete proposal would be:

- What does the end-user Java API look like? Would it make sense to implement the current Java API (with generics etc.) using JavaCPP for the native-call redirection, or would it make sense to define a smaller C++ class and generate its interface? For example, compare the `Tensor` class in [current Java API](http://bytedeco.org/javacpp-presets/tensorflow/apidocs/org/tensorflow/Tensor.html) vs. [JavaCPP wrapped over the C++ Tensor class](http://bytedeco.org/javacpp-presets/tensorflow/apidocs/org/bytedeco/javacpp/tensorflow.Tensor.html). Along the same lines, since so far the primary interest in the Java API has been in deploying trained models in an application - the APIs for that should be succinct and easy to comprehend ([examples](https://github.com/tensorflow/models/tree/master/samples/languages/java)).

- How would we scope the effort required and benefits of it? For example, assuming we stick with the existing `org.tensorflow.Tensor` API, what does it take to back it with JavaCPP? Can we quantify the benefits (e.g., improved performance in some cases, like perhaps creating large tensors on Android or something)? Or if the proposal is to have a different API for the Java user, how do we evaluate? For example, can we evaluate the change in APIs by writing examples including "load a model and serve for inference" and "fine tune a previously trained model" and "construct a trained model".

- Once this is scoped out, who is going to drive the changes? 

- Is it possible to break this down into small sets of changes/projects? For example, the code generator that Karl is working on could just as well be done in Java (no JNI) and doing that may be a reasonable project (Karl has ideas on switching to that, but wanted to get his C++ version in first just because he has that almost working and again, most _users_ of the API won't care whether the Java code was generated one way or another).

I'm not at all suggesting that I'm convinced that JavaCPP isn't the appropriate choice here. However, I haven't had the opportunity to think through all these details, and probably won't have much time to devote to that in the near future. So if someone wants to think this through and write it up and come up with concrete proposals (that can be [shared as an RFC](https://github.com/tensorflow/community) ([example](https://groups.google.com/a/tensorflow.org/d/msg/developers/6Irde5yjUBc/SRool5ghAgAJ))), we're open to that. Perhaps there is some precedence here? For example, I noticed that there are [JavaCPP presets of MXNet](https://github.com/bytedeco/javacpp-presets/tree/master/mxnet) as well, while MXNet also has [handwritten scala bindings](https://github.com/apache/incubator-mxnet/tree/master/scala-package/core/src/main/scala/org/apache/mxnet) instead of generating them from the C++ (though admittedly I know nothing about Scala or the implementation/design choices in MXNet). Perhaps you've been through similar thinking there as well?

Long story short, I'd say that the barrier to "use JavaCPP" isn't anyone's "mindset", it's simply a person putting the effort to dig into the details of what that means. Or perhaps I'm misunderstanding you and there is a concrete proposal you're suggesting?My point isn't about what the end user API should look like, it's about how to get there. There is no need to change what's already been done for the API at all. But you've spend over 2 years hacking in C++ and forcing contributors like @karllessard to contribute in C++. Why not let them contribute to the effort by doing it in Java? We can use the C/C++ API of TensorFlow or of anything else like MXNet for that matter, from Java. Why does no one (other than Skymind) does it that way? I don't know, why should I know? I spend a lot of time arguing about that, but never got a satisfying answer. If no one does something, does it automatically make it wrong?

TensorFlow could have a  policy to do as much as possible in C++, sure, I guess, but you should make that clear if that's the case. Is it the case?@asimshankar Maybe what we need is a separate repo like https://github.com/tensorflow/swift where contributors wouldn't be limited to contrived hybrid C++/Java solutions? Such a project would essentially become a consumer of the core of TensorFlow and evolve from there...@saudet that's similar to what I have mentioned earlier and it seems there is no plan for such integration yet. But even if they are willing to do such project I don't want this to hurt what is being done right now. It is already 2018 and we still do not have a proper implementation of TF for Java/Kotlin. This waiting is at the excruciating level (even c# has a TF implementation now). I personally don't want this to delay for more fancy features, they can be hopefully developed later on.@arnaghizadeh : I agree with you here. Just FYI, I think the major reason why it is taking so long is that a lot of time is spent in code reviews before features can get merged into the master branch. I am not blaming Asim for that, I think he's doing a fantastic job to keep the code neat and under control. But having a separate branch to experiment some features on our side before creating a PR in TensorFlow might help to develop things more dynamically and to get that full-fledged Java client out faster.

If TensorFlow is not able to provide us that branch, maybe we should simply start our own and start to do some cherry-picking after.@karllessard I am not sure if the current setup will let us do that in the Tensorflow repo, though I do think it's a good idea for velocity. @martinwicke is it possible to give a sub-team a branch, or is a cloned repo a better idea?Branches are complicated. I would create a fork, keep its master branch synched with tensorflow/tensorflow, and work on a branch off of that. Then, make occasional PRs from there to tensorflow/tensorflow master. Do you think that would work?@martinwicke :+1: I think that would work, yes, how the commits into that fork would be moderated? 

Right now, I'm doing all my PR from my personal repo, which is very convenient, but the fork would really help if other developers manifest a serious interest in contributing for the Java client also (which seems to be the case reading those previous comments).Oh, my suggestion was that you review the commits on your fork (or, you can also give others write access to let others review). 

If there are more than a couple of regular contributors, we can also set up a special interest group for you, and talk about moving the repo to the tensorflow org. The process would be mainly the same though: you review contributions and you can move at high speed, and you make larger, but less frequent PRs back to TF. @asimshankar what do you think?

We could also talk about moving the Java bindings out of the TensorFlow repo altogether. We'd have to figure out how to package that, but that would remove the need to sync back to TF altogether, which could be quite attractive.

@ewilderj FYI> Oh, my suggestion was that you review the commits on your fork (or, you can also give others write access to let others review).

On my end, I agree with that plan, let's do this for now and see if some other serious contributors would like to do it differently, I'll send a link to that new branch soon, thanks!@martinwicke yep, we're already having SIG conversations.... will post an update on that soon.Nagging Assignee @asimshankar: It has been 64 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.Nagging Assignee @asimshankar: It has been 79 days with no activity and this issue has an assignee. Please update the label and/or status accordingly.This conversation seems to have run its course. Closing this issue since I don't know of any plans on the docs side to publish a separate Java roadmap (here's the [general TF roadmap](https://www.tensorflow.org/community/roadmap) that was recently updated).

Sounds like the mailing lists/SIGs are the best way to keep up with new developments.there is no mention of the Java API in the road-map though, it seems that Java is going to be ignored for TF 2.0?TF 2.0 is certainly focused on Python, as you'll see in the design reviews at https://github.com/tensorflow/community/pulls

The Java APIs will continue to be mainly focused on loading and serving models (to integrate into existing applications) and the low level API for building graphs.  Higher level APIs to build models aren't something that are on the roadmap of the TensorFlow maintainers.

For that we'd encourage community driven efforts. As mentioned above, perhaps a SIG (if there is enough interest in design and development) or just great projects like JavaCPP presets mentioned above. FYI, since TF 1.10, operations wrappers have been added to build and train graphs in Java (please note that it is still at an experimental stage). 

A minimalist example of their usage can be found [here](https://github.com/karllessard/models/tree/java-examples/samples/languages/java/mnist).@karllessard @asimshankar - the dl4j team is committed to supporting the javacpp stack. We have the high level keras api already built (maintained by @maxpumperla ) - we are also seeing people building demos not even a few weeks after its release: https://github.com/tzolov/mtcnn-java - we also have an equivalent api that could easily compliment tf.data.  Rather than a bunch of 1 off repos, why don't we focus on this upcoming TF 2.0 and being able to do a proper java SIG where we can address this?It seems that closing this issue just ignited it ;)

@agibsonccc , personally I'm all for having a SIG where all those matters could be discussed and efforts could be merged, a big ðŸ‘ for this. I'm not sure though where all this is going since the current topic is about the current state of the TF Java client but discussions always tend to be dragged in the directions of other projects. When you talk about focusing on TF2.0, you mean in Tensorflow or in DL4J? @karllessard We're still interested in doing this as part of dl4j or TF we don't care.  It really depends on what the TF team is interested in doing with 2.0. The team had expressed interest in merging efforts somehow. We'd prefer not to be rewriting things your team is already doing. We're interested in providing a graph runner regardless since we have to interop with every stack anyways. We're going to be doing something similar with onnx as well.@karllessard Great work, thanks for the contribution! The JavaCPP Presets for TensorFlow now include your Java ops wrappers, with builds on Maven for Android, Linux, Mac, and Windows, compiled against and bundled with MKL-DNN, CUDA, and cuDNN (that is, no need to install them, all binaries get pulled from Maven), along with a more complex JNI loader than the default one in TensorFlow that works well with multiple class loaders and Windows applications including JavaFX ones:
    https://github.com/bytedeco/javacpp-presets/tree/master/tensorflow

They seem to work fine, but let me know if you find any issues or would like to change something. With a bit more work, I'm sure we could get all this to interoperate with the rest of the C/C++ APIs that come with the presets. That would be nice, given that at that level, JavaCPP can share memory with zero-copy and manage with scopes the resources used by multiple APIs, not only from TensorFlow but from other native libraries as well, such as OpenCV, FFmpeg, or Tesseract:
    http://bytedeco.org/news/2018/07/17/bytedeco-as-distribution/