Some data transformations including over under sampling 1454, outlier removal, instance reduction, and other forms of dataset compression, like that used in BIRCH 3802 entail altering a dataset at training time, but leaving it unaltered at prediction time. In some cases, such as outlier removal, it makes sense to reapply a fitted model to new data, while in others model reuse after fitting seems less applicable. 

As noted LINKLINK, transformers that change the number of samples are not currently supported, certainly in the context of CODESCODES s where a transformation is applied both at CODESCODES and CODESCODES time although a hack might abuse CODESCODES to make this not so. CODESCODES s of CODESCODES s also would not cope with changes in the sample size at fit time for supervised problems because CODESCODES s do not return a modified CODESCODES, only CODESCODES.

To handle this class of problems, I propose introducing a new category of estimator, called a CODESCODES. It must define at least a CODESCODES method, which CODESCODES will call at CODESCODES time, passing the data unchanged at other times. For this reason, a CODESCODES cannot also be a CODESCODES, or else we need to define their precedence. 

For many models, CODESCODES needs only return CODESCODES. For sample compression approaches for example that in BIRCH, this is not sufficient as the representative centroids are modified from the input samples. Hence I think CODESCODES should return altered data directly, in the form of a dict with keys CODESCODES, CODESCODES, CODESCODES as required. It still might be appropriate for many CODESCODES s to only modify CODESCODES ; if necessary, another CODESCODES can be chained that realises the weights as replicated or deleted entries in CODESCODES and CODESCODES. 
