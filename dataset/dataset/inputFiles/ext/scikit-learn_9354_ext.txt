. Description. I noticed that sklearn [CLS] [SEP] metrics [CLS] [SEP] pairwise [CLS] [SEP] pairwise distances function agrees with np [CLS] [SEP] linalg [CLS] [SEP] norm when using np [CLS] [SEP] float64 arrays, but disagrees when using np [CLS] [SEP] float32 arrays [CLS] [SEP] See the code snippet below [CLS] [SEP] Steps Code to Reproduce. CODELCODEL. Expected Results. I expect that the results from sklearn [CLS] [SEP] metrics [CLS] [SEP] pairwise [CLS] [SEP] pairwise distances would agree with np [CLS] [SEP] linalg [CLS] [SEP] norm for both 64 bit and 32 bit [CLS] [SEP] In other words, I expect the following output: CODELCODEL. Actual Results. The code snippet above produces the following output for me: CODELCODEL. Versions. CODELCODEL Same results with python 3 [CLS] [SEP] CODELCODEL. It happens only with euclidean distance and can be reproduced using directly CODESCODES: CODELCODEL. I couldn't track down further the error [CLS] [SEP] I hope this can help [CLS] [SEP] numpy might use a higher precision accumulator [CLS] [SEP] yes, it looks like this. deserves fixing [CLS] [SEP] I'd like to work on this if possible Go for it [CLS] [SEP] So I think the problem lies around the fact that we are using CODESCODES for computing euclidean distance. Because if I try CODESCODES I get the answer 0 for np [CLS] [SEP] float32, while I get the correct ans for np [CLS] [SEP] float 64 [CLS] [SEP] jnothman What do you think I should do then [CLS] [SEP] As mentioned in my comment above the problem is probably computing euclidean distance using CODESCODES So you're saying that dot is returning a less precise result than product then sum [CLS] [SEP] No, what I'm trying to say is dot is returning more precise result than product then sum. CODESCODES gives output CODESCODES. while CODESCODES gives output CODESCODES It is not clear what you are doing, partly because you are not posting a fully stand alone snippet [CLS] [SEP] Quickly looking at your last post the two things you are trying to compare CODESCODES and CODESCODES do not have the same dimensions maybe a copy and paste problem but again hard to know because we don't have a full snippet [CLS] [SEP] Ok sorry my bad. CODELCODEL. OUTPUT. CODELCODEL. The first method is how it is computed by the euclidean distance function [CLS] [SEP] Also to clarify what I meant above was the fact that sum then product has lower precision even when we use numpy functions to do it. Yes, I can replicate this [CLS] [SEP] I see that doing the subtraction initially. allows the precision of the difference to be maintained [CLS] [SEP] Doing the dot. product and then subtracting or negating and adding, as we currently do, loses this precision as the most significant figures are much larger than. the differences [CLS] [SEP] The current implementation is more memory efficient for a high number of. features [CLS] [SEP] But I suppose euclidean distance becomes increasingly irrelevant. in high dimensions, so the memory is dominated by the number of output. values [CLS] [SEP] So I vote for adopting the more numerically stable implementation over the. d asymptotically efficient implementation we currently have [CLS] [SEP] An opinion, ogrisel [CLS] [SEP] agramfort [CLS] [SEP] And this is of course more of a concern since we recently allowed float32s. to be more commonplace across estimators [CLS] [SEP] So for this example product then sum works perfectly fine for np [CLS] [SEP] float64, so a possible solution could be to convert the input to float64 then compute the result and return the result converted back to float32 [CLS] [SEP] I guess this would be more efficient, but not sure if this would work fine for some other example [CLS] [SEP] converting to float64 won't be more efficient in memory usage than. subtraction [CLS] [SEP] Oh yeah you are right sorry about that, but I think using float64 and then doing product then sum would be more efficient computationally if not memory wise [CLS] [SEP] And the reason for using product then sum was to have more computational efficiency and not memory efficiency [CLS] [SEP] sure, but I don't believe there is any reason to assume that it is in fact. more computationally efficient except by way of not having to realise an. intermediate array [CLS] [SEP] Assuming we limit absolute working memory for example by. chunking, why would taking the dot product, doubling and subtracting norms. be much more efficient than subtracting and squaring [CLS] [SEP] Provide benchmarks [CLS] [SEP] Ok so I created a python script to compare the time taken by subtraction then squaring and conversion to float64 then product then sum and it turns out if we choose an X and Y as very big vectors then the 2 results are very different [CLS] [SEP] Also jnothman you were right subtraction then squaring is faster [CLS] [SEP] Here's the script that I wrote, if there's any problem please let me know. CODELCODEL it's worth testing how it scales with the number of samples, not just the. number of features [CLS] [SEP] taking norms may have the benefit of computing some. things once per sample, not once per pair of samples. wrote: anyway, would you like to submit a PR, ragnerok [CLS] [SEP] yeah sure, what do you want me to do [CLS] [SEP] provide a more stable implementation, also a test that would fail under the. current implementation, and ideally a benchmark that shows we do not lose. much from the change, in reasonable cases [CLS] [SEP] I wanted to ask if it is possible to find distance between each pair of rows with vectorisation [CLS] [SEP] I cannot think about how to do it vectorised [CLS] [SEP] You mean difference not distance between pairs of rows [CLS] [SEP] Sure you can do that if you're working with numpy arrays [CLS] [SEP] If you have arrays with shapes n samples1, n features and n samples2, n features, you just need to reshape it to n samples1, 1, n features and 1, n samples2, n features and do the subtraction: CODELCODEL Yeah thanks that really helped 😄 I also wanted to ask if I provide a more stable implementation I won't be using X norm squared and Y norm squared [CLS] [SEP] So do I remove them from the arguments as well or should I warn about it not being of any use [CLS] [SEP] I think they will be deprecated, but we might need to first be assured that. there's no case where we should keep that version [CLS] [SEP] we're going to be quite careful in changing this [CLS] [SEP] it's a widely used and. longstanding implementation [CLS] [SEP] we should be sure not to slow any important. cases [CLS] [SEP] we might need to do the operation in chunks to avoid high memory. usage which is perhaps made trickier by the fact that this is called. within functions that chunk to minimise the output memory retirement from. pairwise distances [CLS] [SEP] I'd really like to hear from other core devs who know about computational. costs and numerical precision [CLS] [SEP] ogrisel, lesteve, rth [CLS] [SEP] wrote: but it would be easier to discuss precisely if you open a PR. Ok I'll open up a PR then, with a very basic implementation of this functionThe questions is what should be done about this for the 0 [CLS] [SEP] 20 release [CLS] [SEP] Could there be some simple temporary improvements event at the cost for example of memory usage that could be considered [CLS] [SEP] The solution and analysis proposed in 11271 are definitely very valuable, but it might require some more discussion to make sure this is the optimal solution [CLS] [SEP] In particular, I am concerned about the fact that now we have some pending discussion about the optimal global working memory in LINKLINK depending on the CPU type etc while this would add yet another level of chunking and the complexity of the whole would be getting a bit of control IMO [CLS] [SEP] But maybe it's just me, looking for a second opinion [CLS] [SEP] What do you think should be done about this issue for the release jnothman amueller ogrisel [CLS] [SEP] Stability trumps efficiency [CLS] [SEP] Stability issues should be fixed even when. efficiency still needs tweaks [CLS] [SEP] working memory's focus was to make things like silhouette with large sample. sizes work [CLS] [SEP] It also improved efficiency, but that can be tweaked down the. line [CLS] [SEP] I strongly believe we should try to get a fix for euclidean distances with. float32 in [CLS] [SEP] We broke it in 0 [CLS] [SEP] 19 by assuming that we could make. euclidean distances work on 32 bit in a naive way [CLS] [SEP] I agree that we need a fix [CLS] [SEP] My concern here is not efficiency but the added complexity in the code base [CLS] [SEP] Taking a step back, scipy's euclidean implementation seems to be LINKLINK and for 32 bit, simply cast them to 64bit [CLS] [SEP] I understand that it's not the fastest but it's conceptually easy to follow and understand [CLS] [SEP] In scikit learn, we use the trick to make computations faster in BLAS, then there are possible improvements due in LINKLINK and now the possible chunked solution to euclidean distance in 32 bit [CLS] [SEP] I'm just looking for input about what the general direction on this topic should be e [CLS] [SEP] g try to upstream some of it to scipy etc [CLS] [SEP] scipy doesn't seem concerned by copying the data [CLS] [SEP] Move to 0 [CLS] [SEP] 21 following the PR [CLS] [SEP] Remove the blocker [CLS] [SEP] CODESCODES. is numerically unstable, if dot x, x and dot y, y are of similar magnitude as dot x, y because of what is known as catastrophic cancellation [CLS] [SEP] This not only affect FP32 precision, but it is of course more prominent, and will fail much earlier [CLS] [SEP] Here is a simple test case that shows how bad this is even with double precision: CODELCODEL. sklearn computes a distance of 0 here both times, rather than sqrt 2 [CLS] [SEP] A discussion of the numerical issues for variance and covariance and this trivially carries over to this approach of accelerating euclidean distance can be found here: Actually the y coordinate can be removed from that test case, the correct distance then trivially becomes I made a pull request that triggers this numeric problem: CODELCODEL. amueller as the problem may be more sever than expected, I suggest re adding the blocker label [CLS] [SEP] Thanks for this very simple example [CLS] [SEP] The reason it is implemented this way is because it's way faster [CLS] [SEP] See below: CODELCODEL. Although the number of operations is of the same order in both methods 1 [CLS] [SEP] 5x more in the second one, the speedup comes from the possibility to use well optimized BLAS libraries for matrix matrix multiplication [CLS] [SEP] This would be a huge slowdown for several estimators in scikit learn [CLS] [SEP] Yes, but just 3 4 digits of precision with FP32, and 7 8 digits with FP64 does cause substantial imprecision, doesn't it [CLS] [SEP] In particular, since such errors tend to amplify [CLS] [SEP] Well I'm not saying that it's fine right now [CLS] [SEP] thumbs up. I'm saying that we need to find a solution in between [CLS] [SEP] There is a PR 11271 which proposes to cast on float64 to do the computations [CLS] [SEP] In does not fix the problem for float64 but gives better precision for float32 [CLS] [SEP] Do you have an example where using an estimator which uses euclidean distances gives wrong results due to the loss of precision [CLS] [SEP] I certainly still think this is a big deal and should be a blocker for 0 [CLS] [SEP] 21 [CLS] [SEP] It was an issue introduced for 32 bit in 0 [CLS] [SEP] 19, and it's not a nice state of affairs to leave [CLS] [SEP] I wish we had resolved it earlier in 0 [CLS] [SEP] 20, and I would be okay, or even keen, to see 11271 merged in the interim [CLS] [SEP] The only issues in that PR that I know of surround optimisation of memory efficiency, which is a deep rabbit hole [CLS] [SEP] We've had this fast version for a long time, but always in float64 [CLS] [SEP] I know, kno10, that it's got issues with precision [CLS] [SEP] Do you have a good and fast heuristic for us to work out when that might be a problem and use a slower but surer solution [CLS] [SEP] Thanks for illustrating this issue with very simple example [CLS] [SEP] I don't think the issue is as widespread as you suggest, however it mostly affects samples whose mutual distance small with respect to their norms [CLS] [SEP] The below figure illustrates this, for 2e6 random sample pairs, where each 1D samples is in the interval [CLS] [SEP] The relative error between the scikit learn and scipy implementation is plotted as a function of the distance between samples, normalized by their L2 norms, for example, CODELCODEL. not sure it's the right parametrization, but just to get results somewhat invariant to the data scale, LINKLINK. For instance, if one takes CODESCODES and CODESCODES the L2 normalized distance is 1e 4 and the relative error on the distance calculation will be 1e 8 in 64 bit, and 1 in 32 bit Or 1e 8 and 1 in absolute value respectively [CLS] [SEP] In 32 bit this case is indeed quite terrible [CLS] [SEP] on the other hand for CODESCODES and CODESCODES, the relative error will be 1e 7 in 32 bit, or the maximum possible precision [CLS] [SEP] The question is how often the case will happen in practice in ML applications [CLS] [SEP] Interestingly, if we go to 2D, again with a uniform random distribution, it will be difficult to find points that are very close, LINKLINK. Of course, in reality our data will not be uniformly sampled, but for any distribution because of the curse of dimensionality the distance between any two points will slowly converge to very similar values different from 0 as the dimentionality increases [CLS] [SEP] While it's a general ML issue, here it may mitigate somewhat this accuracy problem, even for relatively low dimensionality [CLS] [SEP] Below the results for CODESCODES, LINKLINK [CLS] [SEP] So for centered data, at least in 64 bit, it may not be so much of an issue in practice assuming there are more then 2 features [CLS] [SEP] The 50x computational speed up as illustrated above may be worth it in 64 bit [CLS] [SEP] Of course one can always add 1e6 to some data normalized in and say that the results are not accurate, but I would argue that the same applies to a number of numerical algorithms, and working with data expressed in the 6th significant digit is just looking for trouble [CLS] [SEP] The code for the above figures can be found LINKLINK [CLS] [SEP] Any fast approach using the dot x, x +dot y, y 2 dot x, y version will likely have the same issue for all I can tell, but you'd better ask some real expert on numerics for this [CLS] [SEP] I believe you'll need to double the precision of the dot products to get to approx [CLS] [SEP] the precision of the input data and I'd assume that if a user provides float32 data, then they'll want float32 precision, with float64, they'll want float64 precision [CLS] [SEP] You may be able to do this with some tricks think of Kahan summation, but it will very likely cost you much more than you gained in the first place [CLS] [SEP] I can't tell how much overhead you get from converting float32 to float64 on the fly for using this approach [CLS] [SEP] At least for float32, to my understanding, doing all the computations and storing the dot products as float64 should be fine [CLS] [SEP] IMHO, the performance gains which are not exponential, just a constant factor are not worth the loss in precision which can bite you unexpectedly and the proper way is to not use this problematic trick [CLS] [SEP] It may, however, be well possible to further optimize code doing the traditional computation, for example to use AVX [CLS] [SEP] Because sum x y 2 is all but difficult to implement in AVX [CLS] [SEP] At the minimum, I would suggest renaming the method to CODESCODES, because of the sometimes low precision which gets worse the closer two values are, which may be fine initially then begin to matter when converging to some optimum, so that users are aware of this issue [CLS] [SEP] rth thanks for the illustrations [CLS] [SEP] But what if you are trying to optimize, for example, x towards some optimum [CLS] [SEP] Most likely the optimum will not be at zero if it would always be your data center, life would be great, and eventually the deltas you are computing for gradients etc [CLS] [SEP] may have some very small differences [CLS] [SEP] Similarly, in clustering, clusters will not all have their centers close to zero, but in particular with many clusters, x ≈ center with a few digits is quite possible [CLS] [SEP] Overall however, I agree this issue needs fixing [CLS] [SEP] In any case we need to document the precision issues of the current implementation as soon as possible [CLS] [SEP] In general though I don't think the this discussion should happen in scikit learn [CLS] [SEP] Euclidean distance is used in various fields of scientific computing and IMO scipy mailing list or issues is a better place to discuss it: that community has also more experience with such numerical precision issues [CLS] [SEP] In fact what we have here is a fast but somewhat approximate algorithm [CLS] [SEP] We may have to implement some fixes workarounds in the short term, but in the long term it would be good to know that this will be contributed there [CLS] [SEP] For 32 bit, LINKLINK may indeed be a solution, I'm just not so keen of multiple levels of chunking all through the library as that increases code complexity, and want to make sure there is no better way around it [CLS] [SEP] Thanks for your response kno10 [CLS] [SEP] My above comments doesn't take it into account yet I'll respond a bit later [CLS] [SEP] Yes, convergence to some point outside of the origin may be an issue [CLS] [SEP] Well a 10x slow down for their calculation in 64 bit will have a very real effect on users [CLS] [SEP] Tried a quick naive implementation with numba which should use SSE, CODELCODEL. getting a similar speed to scipy CODESCODES so far but I'm not a numba expert, and also not sure about the effect of CODESCODES [CLS] [SEP] Just for future reference, what we are currently doing is roughly the following because there is a dimension that doesn't show in the above notation, CODELCODEL. where both CODESCODES and CODESCODES now use BLAS [CLS] [SEP] I wonder, if aside from using BLAS, this also actually does the same number of mathematical operations as the first version above [CLS] [SEP] n samples x n samples y n features 1 substraction + 1 addition + 1 multiplication. whereas the x [CLS] [SEP] x + y [CLS] [SEP] y 2x [CLS] [SEP] y performs. n samples x n samples y n features 1 addition + 1 multiplication [CLS] [SEP] There is a 2 3 ratio for the number of operations between the 2 versions [CLS] [SEP] Following the above discussion, Made a PR to optionally allow computing euclidean distances exactly LINKLINK. Some WIP to see if we can detect and mitigate the problematic points in LINKLINK. For 32 bit, we still need to merge LINKLINK in some form though IMO, the above PRs are somewhat orthogonal to it [CLS] [SEP] FYI: when fixing some issues in OPTICS, and refreshing the test to use reference results from ELKI, these fail with CODESCODES but succeed with CODESCODES [CLS] [SEP] The numerical differences are large enough to cause a different processing order just decreasing the threshold is not enough [CLS] [SEP] LINKLINK I'm really not caught up on this, but I'm surprised there's no existing solution [CLS] [SEP] This seems to be a very common computation and it looks like we're reinventing the wheel [CLS] [SEP] Has anyone tried reaching out to the wider scientific computing community [CLS] [SEP] Not yet, but I agree we should [CLS] [SEP] The only thing I found about this in scipy was LINKLINK and linked issues [CLS] [SEP] I feel jeremiedbb might have an idea [CLS] [SEP] Unfortunately not a satisfying one yet thumbs down. We'd like to rely on a highly optimized library for this kind of computation, as we do for linear algebra with BLAS libraries such as OpenBLAS or MKL [CLS] [SEP] But euclidean distance is not part of it [CLS] [SEP] The dot trick is an attempt at doing that relying on BLAS level 3 matrix matrix multiplication subroutine [CLS] [SEP] But this is not precise and there is no way to make it more precise using the same method [CLS] [SEP] We have to lower our expectancy either in term of speed or in term of precision [CLS] [SEP] I think in some situations, full precision is not mandatory and keeping the fast method is fine [CLS] [SEP] This is when the distances are used for find the closest tasks [CLS] [SEP] The precision issues in the fast method appear when the distances between points is small compared to their norm in a ratio 1e 4 for float 32 and 1e 8 for float64 [CLS] [SEP] First for this situation to happen, the dataset needs to be quite dense [CLS] [SEP] Then to have an ordering error, you need to have the two closest points within almost the same distance [CLS] [SEP] Moreover, in that case, in a ML point of view, both would lead to almost equally good fits [CLS] [SEP] In the above situation, there is something we can do to lower the frequency of these wrong ordering down to 0 [CLS] [SEP] In the pairwise distance argmin situation [CLS] [SEP] We can move the misordering to points which are not the closest [CLS] [SEP] Essentially using the fact that one of the norm is not necessary to find the argmin, see LINKLINK [CLS] [SEP] It has 2 advantages [CLS] [SEP] It's a more robust up to now I haven't found a wrong ordering yet and it is even faster because it avoids some computations [CLS] [SEP] One drawback, still in the same situation, if at the end we want the actual distances to the closest points, the distances computed with the above method can't be used [CLS] [SEP] They are only partially computed and they are not precise anyway [CLS] [SEP] We need to re compute the distances from each point to it's closest point [CLS] [SEP] But this is fast because for each point there is only one distance to compute [CLS] [SEP] I wonder what I described above covers all the use case of euclidean distances in sklearn [CLS] [SEP] But I suggest to do that wherever it can be applied [CLS] [SEP] To do that we can add a new parameter to euclidean distances to only compute the necessary part in order to chain it with argmin [CLS] [SEP] Then use it in pairwise distances argmin and in pairwise distances argmin min re computing the actual min distances at the end in the latter [CLS] [SEP] When we can't do that, fall back to the slow yet precise one, or add a switch like in 12136 [CLS] [SEP] We can try to optimize it a bit to lower the performance drop cause I agree that LINKLINK does not seem optimal [CLS] [SEP] I have a few ideas for that [CLS] [SEP] Another possibility to keep using BLAS is combining CODESCODES with CODESCODES but this is far from optimal [CLS] [SEP] Both are BLAS level 1 functions, and it involves a copy [CLS] [SEP] This would only be faster in dimension 100 [CLS] [SEP] Ideally we'd like the euclidean distance to be included in BLAS [CLS] [SEP] Finally, there is another solution, consisting in upcasting [CLS] [SEP] This is done in 11271 for float32 [CLS] [SEP] The advantage is that the speed is just half the current one and precision is kept [CLS] [SEP] It does not solve the problem for float64 however [CLS] [SEP] Maybe we can find a way to do a similar thing in cython for float64 [CLS] [SEP] I don't know exactly how but using 2 float64 numbers to kind of simulate a float128 [CLS] [SEP] I can give it a try to see if it's somewhat doable [CLS] [SEP] Is that something the libraries would consider [CLS] [SEP] If OpenBLAS does it we would be in a pretty good situation already [CLS] [SEP] Also, what's the exact differences between us doing it and the BLAS doing it [CLS] [SEP] Detecting the CPU capabilities and deciding which implementation to use, or something like that [CLS] [SEP] Or just having compiled versions for more diverse architectures [CLS] [SEP] Or just more time energy spend writing efficient implementations [CLS] [SEP] This is interesting: an alternative implementation of the fast unstable method but claiming to be much faster than sklearn: LINKLINK. doesn't solve this issue at all though lol This discussion seems related LINKLINK Here's what julia does: LINKLINK. It allows setting a precision threshold to force recalculation [CLS] [SEP] Answering my own question: OpenBLAS has what looks like hand written assembly for each processor not architecture [CLS] [SEP] and heutistics to choose kernels for different problem sizes [CLS] [SEP] So I don't think it's an issue of getting it into openblas as much as finding someone to write optimize all those kernels [CLS] [SEP] Thanks for the additional thoughts [CLS] [SEP] In a partial response, Yeah, I also was hoping we could do more of this in BLAS [CLS] [SEP] Last time I looked nothing in standard BLAS API looks close enough but then I'm not an expert on those [CLS] [SEP] LINKLINK might offer more flexibility but since we are not using it by default it's of somewhat limited use though numpy might someday LINKLINK. Great to know [CLS] [SEP] Should we open a separate issue for the faster approximate computation linked above [CLS] [SEP] Seems interestingTheir speedup on CPU of x2 x4 might be due to LINKLINK [CLS] [SEP] I would rather open an issue on scipy once we have studied this question enough to come up with a reasonable solution there and then possibly backport it as I feel euclidean distance is something basic enough that should be of interest to many people outside of ML and at the same time having the opinion of people there for example on accuracy issues would be helfpul [CLS] [SEP] It's up to 60x, right [CLS] [SEP] hum not sure about that [CLS] [SEP] They are benchmarking CODESCODES, which uses scipy's one [CLS] [SEP] They should do CODESCODES and their speedup wouldn't be as good thumbs up. As shown far earlier in the discussion, sklearn can be 35x faster than scipyYes, they benchmarks are only 30 better better with CODESCODES instead of CODESCODES, CODELCODEL. Doesn't sound straightforward [CLS] [SEP] BLAS is a set of specs for linear algebra routines and there are several implementations of it [CLS] [SEP] I don't know how open they are to adding new features not in the original specs [CLS] [SEP] For that maybe blis would be more open but as said before, it's not the default for now [CLS] [SEP] Opened LINKLINK on the CODESCODES vs CODESCODES handling in CODESCODES [CLS] [SEP] I need some clarity about what we want for this [CLS] [SEP] Do we want CODESCODES to be close in the sense of CODESCODES for both 'euclidean' and 'sqeuclidean' [CLS] [SEP] It's a bit tricky [CLS] [SEP] Because x is close to y does not mean x² is close to y² [CLS] [SEP] Precision is lost during squaring [CLS] [SEP] The julia workaround linked above is very interesting and is kind of straightforward to implement [CLS] [SEP] However I suspect that it does not work as expected for 'sqeuclidean' [CLS] [SEP] I suspect that you have to set the threshold way below to get the desired precision [CLS] [SEP] The issue with setting a very low threshold is that it induces a lot of re computations and a huge drop of performances [CLS] [SEP] However this is mitigated by the dimension of the dataset [CLS] [SEP] The same threshold will trigger way less re computations in high dimension distances are bigger [CLS] [SEP] Maybe we can have 2 implementations and switch depending on the dimension of the dataset [CLS] [SEP] The slow but safe one for low dimensional ones there not much difference between scipy and sklearn in that case anyway and the fast + threshold one for high dimensional ones [CLS] [SEP] This will need some benchmarks to find when to switch, and set the threshold but this may be a glimmer of hope thumbs up Here are some benchmarks for speed comparison between scipy and sklearn [CLS] [SEP] The benchmarks compare CODESCODES with CODESCODES for Xs of all sizes [CLS] [SEP] Number of samples goes from 2⁴ 16 to 2¹³ 8192, and number of features goes from 2⁰ 1 to 2¹³ 8192 [CLS] [SEP] The value in each cell is the speedup of sklearn vs scipy, for example below 1 sklearn is slower and above 1 sklearn is faster [CLS] [SEP] The first benchmark is using the MKL implementation of BLAS and a single core [CLS] [SEP] LINKLINK. The second one is using the OpenBLAS implementation of BLAS and a single core [CLS] [SEP] It's just to check that both MKL and OpenBLAS have the same behavior [CLS] [SEP] LINKLINK. The third one is using the MKL implementation of BLAS and 4 cores [CLS] [SEP] The thing is that CODESCODES is parallelized through a BLAS LEVEL 3 function but CODESCODES only uses a BLAS LEVEL 1 function [CLS] [SEP] Interestingly it almost doesn't change the frontier [CLS] [SEP] LINKLINK. When n samples is not too low 100, it seems that the frontier is around 32 features [CLS] [SEP] We could decide to use cdist when n features 32 [CLS] [SEP] This is faster and there no precision issue [CLS] [SEP] This also has the advantage that when n features is small, the julia threshold leads to a lot of re computations [CLS] [SEP] Using cdist avoids that [CLS] [SEP] When n features 32, we can keep the CODESCODES implementation, updated with the julia threshold [CLS] [SEP] Adding the threshold shouldn't slow CODESCODES too much because the number of features is high enough so that only a few re computations are necessary [CLS] [SEP] jeremiedbb great, thank you for the analysis [CLS] [SEP] The conclusion sounds like a great way forward to me [CLS] [SEP] Oh, I assume this was all for float64, right [CLS] [SEP] What do we do with float32 [CLS] [SEP] upcast always [CLS] [SEP] upcast for 32 features [CLS] [SEP] I've not read through the comments carefully will soon, just FYI that float64 has it limitations, see 12128 qinhanmin2014 yes, float64 precision has limitations, but it is precise enough for producing reliable fp32 results for all I can tell [CLS] [SEP] The question is at which parameters an upcast to fp64 is actually cheaper than using cdist from scipy [CLS] [SEP] As seen in above benchmarks, even multi core BLAS is not generally faster [CLS] [SEP] This seems to mostly hold for high dimensional data over 64 dimensions; before that the benefit is usually not worth the effort IMHO and since Euclidean distances are not that reliable in dense high dimensional data, that use case IMHO is not of highest importance [CLS] [SEP] Many users will have less than 10 dimensions [CLS] [SEP] In these cases, cdist seems to usually be faster [CLS] [SEP] Actually it's for both float32 and float64 I mean very similar [CLS] [SEP] I suggest to always use cdist when n features 32 [CLS] [SEP] Upcasting will slowdown by a factor of 2 so I guess around n features 64 [CLS] [SEP] But not everyone, so we still need to find a solution for high dimensional data [CLS] [SEP] Very nice analysis jeremiedbb [CLS] [SEP] For low dimensional data it would definitely make sense to use cdist then [CLS] [SEP] Also, FYI scipy's cdist upcasts float32 to float64 LINKLINK, I'm not sure if this is due to accuracy issues or something else [CLS] [SEP] Overall, I think it could make sense to add the algorithm parameter to CODESCODES as suggested in LINKLINK, possibly with a default to None so that it could also be set via a global option as in LINKLINK [CLS] [SEP] There's also an interesting approach in Eigen3 to compute stable norms: LINKLINK that I haven't really grokked yet Good Explanation, Improved my understandingWe haven't made any progress on this at the sprint and we probably should [CLS] [SEP] and rth is not around today [CLS] [SEP] I can join remotely if you set a time [CLS] [SEP] Maybe in the beginning of afternoon [CLS] [SEP] To summarize the situation, For precision issues in Euclidean distance calculations, in the low dimensional case, as jeremiedbb showed above, we should probably use cdist. in the high dimensional case and float32, we could choose between, chunking, computing the distance in 64 bit and concatenating. falling back to cdist in cases when precision is an issue how is an open question reaching out for example to scipy might be useful LINKLINK. Then there are all the issues of inconsistencies between euclidean, sqeuclidean, minkowski, etc [CLS] [SEP] In terms of the precisions, jeremiedbb, amueller and I had a quick chat, mostly just milking Jeremie for his expertise [CLS] [SEP] He is of the opinion that we don't need to worry so much about the instability issues in an ML context in high dimensions in float64 [CLS] [SEP] Jeremie also implied that it is hard to find an efficient test for whether good results have been returned cf [CLS] [SEP] 12142. So I think we're happy with rth's LINKLINK with the upcasting for float32 [CLS] [SEP] Since cdist also upcasts to float64, we could reimplement cdist to take float32 but with float64 accumulators [CLS] [SEP] or could use chunking, if we want less copying in low dim float32 [CLS] [SEP] Does Celelibi want to change the PR in 11271, or should someone else one of us [CLS] [SEP] produce a complete pull request [CLS] [SEP] And once this has been fixed, I think we should make sqeuclidean and minkowski p in 0,1 use our implementations [CLS] [SEP] We've not discussed discrepancy with NearestNeighbors [CLS] [SEP] Another sprint thumbs up After a quick discussion at the sprint we ended up on the following way: in high dimensional case 32 or 64 choose the best: upcast by chunks to float64 when it's float32 and keep the 'fast' method [CLS] [SEP] For this kind of data, numerical issues, on float64, are almost negligible I'll provide benchmarks for that. in low dimensional case: implement the safe computation instead of using scipy cdist because of the upcast in sklearn [CLS] [SEP] It's tempting to throw upcasting float32 into 0 [CLS] [SEP] 20 [CLS] [SEP] 3 also. This is very interesting [CLS] [SEP] I wasn't actually expecting this result [CLS] [SEP] I re did your benchmark and found a very similar result [CLS] [SEP] Except I would advocate for a lower decision boundary [CLS] [SEP] My benchmark would suggest 8 features [CLS] [SEP] LINKLINK. The cost of being wrong is not symmetric [CLS] [SEP] CODESCODES is better only for computations lasting less than a few seconds and it gets slow really fast when the number of feature increase [CLS] [SEP] So, better use the BLAS implementation when in doubt [CLS] [SEP] Edit: This benchmark was for float64, but I also find that upcasting float32 matrices to float64 only barely add a few percent to the total time and doesn't change the conclusion [CLS] [SEP] I noticed that the threshold depends on the machine you're running the benchmarks on [CLS] [SEP] I suspect it may have to do with the AVX instructions [CLS] [SEP] I realized the benchmarks I published were run on a machine which didn't have AVX2 instructions, only AVX [CLS] [SEP] And on a machine which have AVX2, I got similar results to yours [CLS] [SEP] But the question is not only about performance but also about precision and it's more likely to have precision issues when the dimension is small [CLS] [SEP] Maybe 16 is a good compromise [CLS] [SEP] What do you think [CLS] [SEP] In regards of this discussion, I'd say we need to benchmark the accuracy to take an informed decision [CLS] [SEP] However, in regards of your PR, the accuracy shouldn't be an issue anymore [CLS] [SEP] But at the cost of a slightly more expensive computation [CLS] [SEP] Therefore the threshold should probably be decided by benchmarking your PR [CLS] [SEP] Benchmarking accuracy is not that easy [CLS] [SEP] Because the difficult cases will not be uniformly distributed [CLS] [SEP] And it may be problematic if it happens undetected in a corner case [CLS] [SEP] Usually, you will want to have guaranteed numerical accuracy within affordable CPU limits [CLS] [SEP] But as mentioned elsewhere a single feature with 10000000 [CLS] [SEP] 01 and 10000000 [CLS] [SEP] 00 should be enough to trigger numeric instability with fp64 when using the known problematic equation, 10000 and 10001 with fp32 [CLS] [SEP] With 1024 features, try. CODELCODEL. this was using 0 [CLS] [SEP] 19 [CLS] [SEP] 1 The correct distance is 0 [CLS] [SEP] 32 [CLS] [SEP] As you can see, the numeric instabilities tend to get worse with the number of features unless your data is sparse [CLS] [SEP] Here, the result has less than two digits of precision with FP64 [CLS] [SEP] 13410 does not fix this specific case [CLS] [SEP] i [CLS] [SEP] e float64 + high dimension [CLS] [SEP] It fixes it for float32 however [CLS] [SEP] But we decided that for float64 + high dim, we keep it as it was, because the accuracy issues are very unlikely to happen and don't really apply to machine learning use cases [CLS] [SEP] In your example, X and X have norms equal to 320000 [CLS] [SEP] 32 and 320000 and their distance is 0 [CLS] [SEP] 32, for example 1e 6 times their norm [CLS] [SEP] In machine learning, the 16 significant digits in float64 are not all relevant [CLS] [SEP] I would be more moderate on this one [CLS] [SEP] Reducing the dimensionality is a usual first step in ML [CLS] [SEP] MDS can be used for that, and it makes a heavy use of the euclidean distance matrix [CLS] [SEP] If someone want to have a look at improving the accuracy of the float64 case, there's a way to use two floats to represent the intermediate results [CLS] [SEP] Although I think it starts to fall beyond the scope of scikit learn [CLS] [SEP] ftp: LINKLINK I was not clear [CLS] [SEP] I'm not saying high dimensional data does not apply to machine learning [CLS] [SEP] I'm saying that the kind of precision issues which happen in float64 involves points which distance is 6 orders of magnitude smaller than their norms [CLS] [SEP] Having such a precision has no meaning in a realistic machine learning model. I am not at all convinced that this is that generally true [CLS] [SEP] In this example, we have lost 15 of 16 digits in precision [CLS] [SEP] I'd agree if we would use half of the precision, but we don't have such a relationship [CLS] [SEP] The loss from downcasting FP64 to FP32 may often be tolerable because of measurement precision [CLS] [SEP] And consumer grade GPUs are much faster with FP32 than with FP64, for example in some cases, they allow FP32 data and FP64 accumulators now, though, and for neural networks inference, you may even see int8 now [CLS] [SEP] But that doesn't hold everywhere [CLS] [SEP] For example in k means clustering, there is the assumption that clusters differ substantially in their means and that we don't know the means beforehand, and hence we have a loss in precision here [CLS] [SEP] If you have many clusters, some of their norms can be large compared to their separation [CLS] [SEP] Furthermore, after the first initial iterations, its often small differences in distance that make one point switch to another cluster [CLS] [SEP] Loss of precision here can affect results, and could cause instability [CLS] [SEP] Now consider k means on time series fragments with many variables [CLS] [SEP] With increasing data sizes, we must assume that the distances to the nearest neighbor get smaller, and unless your norms are 0, they will eventually be smaller than the vector norms and cause problems [CLS] [SEP] So this will likely become more severe with increasing data set sizes [CLS] [SEP] The curse of dimensionality says that the largest and the smallest distances get more and more similar; so in order to compute the correct nearest neighbor ranking, we may need good precision in high dimensional data [CLS] [SEP] On the 20news data set, the smallest non zero distance is around 0 [CLS] [SEP] 02 the norms are all 1 [CLS] [SEP] But that is just 10k instances, and fairly diverse contents [CLS] [SEP] Now assume the data set was about near duplicate detection instead [CLS] [SEP] I would not be sure this unlikely happens in ML [CLS] [SEP] of course it won't affect everybody though [CLS] [SEP] When I say In machine learning, the 16 significant digits in float64 are not all relevant [CLS] [SEP] I'm not speaking of the computed distance, I'm speaking of the data. In machine learning, your data comes from a measure, and there's no measure precise to the 9th digit besides very few ones in particle physics [CLS] [SEP] So in your example of CODESCODES and CODESCODES, how would you give some importance to a distance of 0 [CLS] [SEP] 01 when your uncertainty on the values of X are way bigger [CLS] [SEP] For KMeans, first there's a way to overcome a large part of losses of precision [CLS] [SEP] When you're looking for the closest center of an observation x, you don't need to add the norm of x to the distance calculation which avoids the catastrophic cancellation in most cases [CLS] [SEP] Then, kmeans clusters based on euclidean distances [CLS] [SEP] But you don't know if this is the exact way your data are gathered [CLS] [SEP] In fact there's a 0 probability that your data is clustered that way [CLS] [SEP] Kmeans gives an estimation of how your data could be clustered and points which are at the frontier of 2 clusters can definitely not be considered belonging with certainty to one or the other [CLS] [SEP] What's your interpretation of a point at the same distance of 2 clusters [CLS] [SEP] Mine is either the 2 clusters should be only one cluster or KMeans is not the best algo to cluster my data or even kmeans gives me a somewhat good idea of how my data is clustered but I know that frontiers of clusters are not relevant [CLS] [SEP] The use of only b 2 2ab does not have catastrophic cancellation but the same loss in precision in the digits that make the difference [CLS] [SEP] The results are the same as if you added the norm of a to each distance afterwards; if the distances are much smaller than the norm of a, then you get a loss in precision that is avoidable by doing the computations the traditional way without BLAS hacks [CLS] [SEP] So you actually can NOT overcome the numerical problem this way [CLS] [SEP] K means is an optimization problem [CLS] [SEP] So such hacks may mean that sklearn finds only worse solutions than other tools [CLS] [SEP] And as indicated before, this can also cause instabilities [CLS] [SEP] In the worst case, this could cause sklearn kmeans to iterate through the same states until CODESCODES with no improvement assuming tol 0, if you want to find a local optimum, which theory would say is impossible [CLS] [SEP] Until k means has converged, you can't say much about points with the same distance to two clusters [CLS] [SEP] The next iteration, the means may have moved and the difference could become much larger and matter [CLS] [SEP] I am not a big fan of k means because it doesn't work too well on noisy data [CLS] [SEP] But there are variations that handle such cases better [CLS] [SEP] But nevertheless, if you use it, you should probably try to get the full quality which is why I also always use CODESCODES and not make it worse than necessary [CLS] [SEP] It's cheap enough to do the proper calculations and, as mentioned, the problems get worse with data size so for small data, the slower runtime does usually not matter, for larger data sets the precision becomes more likely important [CLS] [SEP] Depending on the application, the difference between CODESCODES and CODESCODES can matter [CLS] [SEP] And as I showed before, if you use multiple features the problems arise earlier [CLS] [SEP] With fp32 as little as 10000 and 10001 with a single feature and 100 vs [CLS] [SEP] 101 with 100 features I guess: As mentioned, the mean may have a physical meaning that you don't want to lose [CLS] [SEP] If you have data with temperatures in Kelvin, you don't want to 0:1 scale them or center them; that would ruin your ratio scale [CLS] [SEP] Now if you want to compare, for example, time series of the temperature of some steel product as it cools down, and figure out if the cool down process affects the reliability of your steel product [CLS] [SEP] You may be having temperatures of over 700 K, and the time series may have hundreds of data points if you want to analyze the cooldown process [CLS] [SEP] Even with just 5 digits of input precision 0 [CLS] [SEP] 01K with the length of the time series the numeric problem can occur [CLS] [SEP] You may again end up with only 1 2 digits in the result [CLS] [SEP] I don't think you can just rule out that precision ever matters in ML if you have this catastrophic kind of effect [CLS] [SEP] Its a different if you could guarantee to always get, say 10 of 16 digits in precision [CLS] [SEP] Here you can't do that, you may have 0 digits right in the worst case that is why it's catastrophic [CLS] [SEP] The raw values from the real world rarely have that kind of accuracy, that's right [CLS] [SEP] But ML isn't limited to that kind of input [CLS] [SEP] One might want to apply ML to mathematical problems, like applying MDS on the graph of a rubik's cube like puzzle or clustering the successful strategies found by your swarm of RL agents playing pacman [CLS] [SEP] Even if the initial source of the information is the real world, there might be some mid way processing that makes most digits relevant to the clustering algorithm [CLS] [SEP] Like the result of a gradient descent on a function whose parameters are statistically sampled in the real world [CLS] [SEP] I'm actually wondering why we're still discussing this [CLS] [SEP] I guess we all agree that scikit learn should try its best in the trade off accuracy vs [CLS] [SEP] computation time [CLS] [SEP] And whoever isn't happy with the current state should submit a pull request [CLS] [SEP] So you actually can NOT overcome the numerical problem this way [CLS] [SEP] There is a loss of precision, but it can't cause a catastrophic cancellation at least when a and b are close, and you can show that the relative error on the distance which is not a distance stays small [CLS] [SEP] In the case of KMeans where you're only interested in finding the closest center, you have enough precision to keep the ordering right [CLS] [SEP] If at the end you want the inertia, then you can just calculate the distances of each point to its cluster center with the exact formula [CLS] [SEP] Besides, KMeans is not a convex optimization problem, so even if you let it run with tol 0 until convergence, you end up in a local minima which can be far off the global minima even with kmeans++ initialization [CLS] [SEP] So I'd rather run kmeans many times with different init and a reasonably small number of iterations [CLS] [SEP] You'll have better chance to end up in a better local minima [CLS] [SEP] Then you can rerun the best one until convergence [CLS] [SEP] The relative error compared to the real distance can be arbitrary large, and hence cause wrong nearest neighbors [CLS] [SEP] Consider the case where a ² b ² 1, for example on tf idf [CLS] [SEP] Assume that the vectors are very close [CLS] [SEP] Then ab is also close to 1, and at this point you already lost much of your precision [CLS] [SEP] As I wrote above, the error is there, even if you don't have catastrophic cancellation [CLS] [SEP] Consider 8 digits of precision [CLS] [SEP] The real distance may be 0 [CLS] [SEP] 000012345678 and can be computed with eight digits using FP32 and regular Euclidean distance [CLS] [SEP] But with this equation, you compute the value ab 0 [CLS] [SEP] 99998765432 instead, which with FP32 will be truncated to approximately 0 [CLS] [SEP] 99998765 at best, so you lost three digits of precision unnecessarily in this example [CLS] [SEP] The loss is as big as in the catastrophic case [CLS] [SEP] If the distances are much smaller than the norms, your precision can become arbitrarily bad with this approach [CLS] [SEP] Yes, kmeans is not convex [CLS] [SEP] But then you will want to at least find a local optimum, and not get stuck or even oscillate because the resulting errors behave erratically because your precision is too low [CLS] [SEP] So you at least get a chance to find the global one in well behaved cases and with multiple attempts [CLS] [SEP] I appreciate this discussion, but what we really need is a solution that is no worse than what we were doing before we stopped upcasting things to float64 [CLS] [SEP] In that sense, Celelibi's upcasting solution was sufficient [CLS] [SEP] Using the exact solution in low dimensions is an added improvement on what we used to do [CLS] [SEP] Regarding a future version, do you feel any more confidence to efficiently detect when we might consider the exact computation in high dimensions [CLS] [SEP] I've run a benchmark to evaluate the average accuracy of the float64 case with random numbers [CLS] [SEP] I compare 3 algorithms: CODESCODES, CODESCODES and CODESCODES [CLS] [SEP] The exact result to compare to has been obtained using mpmath with a precision of 256 bits [CLS] [SEP] CODESCODES and CODESCODES have 100 samples and a variable number of features and are filled with random numbers between 2 and. On the following gif, there's one image per number of feature between 1 and 200 [CLS] [SEP] On each image, each dot represent the relative error of the squared euclidean distance between one of the 10000 pair of vectors of CODESCODES and CODESCODES [CLS] [SEP] The relative error is multiplied by 2 53 for readability, which corresponds roughly to the ULP unit [CLS] [SEP] The curves above are the approximate distribution using a kernel density estimate [CLS] [SEP] LINKLINK. Note that the graphs were cut at 6 ULP for readability [CLS] [SEP] It shows the average case, not the worse case [CLS] [SEP] The error of the expanded formula can grow pretty large [CLS] [SEP] My analysis of this result is that on average, the relative error of the expanded formula can be very large with few features, but quickly become similar to that of the difference and numpy sum [CLS] [SEP] The threshold being between 5 and 10 features [CLS] [SEP] I'm also currently trying to find an upper bound for the error of the expanded formula as well as pathological examples [CLS] [SEP] I think kno10's concern is that we are often interested in cases where. points are not randomly distributed, but are near each other or have unit. norm [CLS] [SEP] Indeed, but I needed to be convinced that in practice, it's not complete BS [CLS] [SEP] To complete the comment above: the relative error of the formula CODESCODES seems to be unbounded [CLS] [SEP] Unless my analysis is wrong, when CODESCODES and CODESCODES are close to each other, the relative error can be up to CODESCODES [CLS] [SEP] At least theoretically [CLS] [SEP] In practice, the worst case I found is a relative error of CODESCODES [CLS] [SEP] CODELCODEL. Flipping the sign of the result would actually make it closer to the truth [CLS] [SEP] This is the most dramatic example I could find, but actually changing the exponent in the values of CODESCODES and CODESCODES doesn't change the relative error [CLS] [SEP] CODELCODEL I think a histogram plot in ULPs would make more sense than above animation with the within ULP error distribution [CLS] [SEP] So 0 ULP error and 1 ULP error are as good as it gets [CLS] [SEP] 2 ULP is likely unavoidable because of the sqrt [CLS] [SEP] Any larger errors are worth investigating I assume [CLS] [SEP] Using CODESCODES is reasonable as long as exact is large [CLS] [SEP] But once we are getting numerical challenges for the exact value, this becomes quite unstable [CLS] [SEP] In such cases, CODESCODES may be worth using instead, for example looking at the precision of our distance computations compared to the input data, not compared to the derived distances [CLS] [SEP] If we have two one dimensional values that only differ by 1 ULP, and error of 2 ULP may seem huge; but we are at input data resolution already, so the results are quite unstable [CLS] [SEP] Note that with multiple dimensions, we may get a higher resolution in the input data [CLS] [SEP] Consider input data of the type CODESCODES vs [CLS] [SEP] CODESCODES [CLS] [SEP] For example if we have a constant attribute in the input data, say, a white pixel in MNIST [CLS] [SEP] With the difference based equation this will be fine, but the dot version gets into trouble, doesn't it [CLS] [SEP] That is why one dimensional experiments may not be enough to study this [CLS] [SEP] I'm not sure I see how you would have represented it [CLS] [SEP] There would be one histogram per number of feature and per algorithm [CLS] [SEP] There's not much I can do beside a 3D plot or an animation [CLS] [SEP] I'm not sure what you mean by unstable in this context [CLS] [SEP] The exact value should be computed with whatever it takes to make it exact [CLS] [SEP] Speaking of which, I should have computed the relative error with arbitrary precision too in my plot, instead of comparing to the exactly rounded result [CLS] [SEP] I updated my plot, the weird waves disappeared [CLS] [SEP] If I understand your idea correctly, you would rather compare the absolute error to the magnitude of the input data [CLS] [SEP] Using the vector norms as an aggregated measure of the magnitude of the inputs [CLS] [SEP] Whereas the standard relative error compare it to the magnitude of the exact result [CLS] [SEP] I think with this metric you try to capture how much faulty is an algorithm [CLS] [SEP] But it actually doesn't seem particularly useful for a few reasons [CLS] [SEP] It doesn't really say how many digits of the result are inexact [CLS] [SEP] Actually, most algorithms would have a score less than 1e thumbs down 5 [CLS] [SEP] Even the expanded formula dot based algorithm would have a score bounded by something like 5 ULP input rough estimation, I didn't write the full proof [CLS] [SEP] And since both metrics are just a rescaled version of the absolute error CODESCODES, they would rank the algorithms in the same order when evaluated on the same inputs [CLS] [SEP] So it's the same as the usual relative error, just with a value interpretation less useful IMO [CLS] [SEP] The dot based algorithm would have a relative error of CODESCODES, meaning that the error is as large as the exact result, and thus, no digit of the result is correct [CLS] [SEP] And your metric would have a value of CODESCODES meaning that relative to the scale of the vector norm, only the 16th digit is off [CLS] [SEP] I'm unsure what you're trying to show with this example [CLS] [SEP] If we are still concerned about the precision of euclidean distances with float64, probably better to summarize this discussion in a new issue as there are 100 comments here [CLS] [SEP] 