Here is an overview of the work done so far relating to plotting:

 LINKLINK Decision Regions of Classifiers
 LINKLINK Confusion matrix and grid search
 LINKLINK Calibration curve
 LINKLINK Partial Dependence

To help control the scope of CODESCODES, I propose we only do plotting on the axes level and not the figure level. The user would pass in the axes as a keyword. As a convenience, the default of CODESCODES will be CODESCODES. Only in this case, will the plotting function generate a axes figure to plot on.Thanks for opening this issue, ping jnothman amueller GaelVaroquaux according to gitter
 8425 is not related to Decision Regions of Classifiers,
I prefer to move plot tree and plot partial dependence to sklearn. plot and solve 13335 in 0.21 maybe introduce a function to plot the decision boundary, since it's important and not easy for beginners IMO. What do others think? 



Good idea, but not consistent with existing functions plot tree and plot partial dependence, right?There are cases where you need to output modify a figure, such as with
multiple subplots see seaborn's facet plots etc, and upsetplot for
example. Can you give reasons why you want to limit it to axes?































 qinhanmin2014 CODESCODES does not seem to adjust the figure. CODESCODES does make multiple plots based on CODESCODES. Although, it can be refactored into an axes level plot. A user would need to call CODESCODES multiple times giving it different axes and features.



 jnothman Seaborn has LINKLINK that clearly separates figure level plot and axes level plots. If we can properly document this behavior in scikit learn, it is possible to have these figure level plots. My biggest concern with figure level plots, is they are harder to maintain and test. There will be elements from one axes that may overlap with another axes. Although, we can work around this by structuring figures in such a way that overlapping happens less often.

In terms of testing, we can go the way of seaborn and test directly matplotlib objects or the yellowbrick way where we do pixel level testing. I tend to favor the testing the matplotlib objects.My 2 cents:

 thumbs up for containing the functions accessing matplotlib in a common subpackage, or, on a module in each subpackage sklearn. linear models. plot, sklearn. ensemble. plot.

 As mentioned by thomasjpfan, only accessing axes makes it easier to test.

 Also, a long time ago, there was discussion in the ecosystem to give other plotting backends an Axes like object for compatibility. I don't know where that went. A quick Googling doesn't show much. The closest is plotly. tools. mpl to plotly, which doesn't really need this restriction, so I think that argument is vain.

I agree but I also think that showing the users how to plot results such as decision boundaries is one of the goals of the examples.

If I want a quick first plot of a result, plotting functions are great, especially for complicated plots such as plotting a tree, but I very often like to tweak the plot to my needs and for that reason I prefer to rely on existing examples and modify the code.

Regarding the name of the module, IMO CODESCODES is more versatile than CODESCODES:

 I can't think of any plot that isn't some kind of inspection 
 12599 Partial Dependence already introduces CODESCODES 

no strong opinion, will vote thumbs up for both name. Maybe plot is more straightforward?

Again I'm interested in creating the new module before 0.21 and move plot tree and plot partial dependence there. Ideally we should also reach consensus on the API for example, axes level figure level.Other point in favor of CODESCODES:

We may want inspect tools that offer plotting as an option. For example, print the characteristics of a tree number of nodes, leaves, split points, etc. and optionally plot it with matplotlib.


 

I would be in favor of using axes instead of figures, as suggested sigh, I'll need to change PDPs again. It's easier for us to support and test. It's a little more work for the users, but it also allows for more control.



 inspect is loaded in Python it's a module in the standard library. I
would avoid using the same name.



This shouldn't delay 0.21. Our goal is to release early, and hopefully
release early again.

would avoid using the same name.

I propose CODESCODES. It goes well with our CODESCODES name.We might want to inspect something that's not a model encoder, preprocessor, grid search results. 

 CODESCODES then?Those things are also models thumbs up 

Gael's suggestion of a public plot submodule on each subpackage is worth
considering.
FWIW, I'd also prefer CODESCODES to CODESCODES, since it's more intuitive for most users to find it. People are more likely trying to plot their models than inspect their models when searching on search engines for instance, or looking at the possible autocomplete options on their IDE.

If so, where shall we put CODESCODES plot decision boundary CODESCODES?

Regarding 12599, NicolasHug I doubt whether CODESCODES partial dependence CODESCODES should be in the new module. for example, ensemble. partial dependence + plot. plot partial dependence 

sklearn. plot?

I don't want to push too hard for this solution. However, I agree with
the feeling that plot may be easier to discover for end users.



I don't understand what you mean. 12599 deprecates CODESCODES in favor of CODESCODES of course CODESCODES is subject to change based on this discussion. The API also differs between the 2 implementations.

 

I'm fine with CODESCODES, I'm just concerned about a potential high overlap with an eventual inspection module, but I won't push it further thumbs up 



But so far all the plotting tools that are proposed PDPs, Calibration, Confusion matrix and decision region aren't specific to a single module.

Apologies I haven't looked at that PR in detail. Maybe CODESCODES inspect. partial dependence CODESCODES + CODESCODES plot. plot partial dependence CODESCODES?

I like a clear separation between computing the values and plotting it.
It's an model view like separation, and it should help increase the
reusability.
Wasn't GaÃ«l earlier proposing sklearn. inspect. partial dependence and
sklearn. inspect. plot. plot partial dependence Substitute some other name
for inspect if appropriate? I don't mind this.


Yes, but I asked him where shall we put CODESCODES plot decision boundary CODESCODES and seems that he changed his mind?FYI, I updated the PDP PR LINKLINK following the recommendations above:

 CODESCODES is in CODESCODES 
 CODESCODES is in CODESCODES 

The docs are here LINKLINK 

Note that the user guide only includes the CODESCODES module for now. I don't think it makes sense to have a user guide section that would only talk about CODESCODES, since its constraints behaviour is the same as that of CODESCODES.

 This is the kind of overlap that I was worried about 

Of course if you think it's still better to have separate user guides for CODESCODES and CODESCODES, I'll do it.
partial dependence is in sklearn. model inspection
plot partial dependence is in skearn. plot

 thumbs up 



 thumbs up 

So we've decided to use the name sklearn. plot?
I find sklearn. plot importing dependencies from across sklearn to be a bit weird when we have avoided putting everyone in the root namespace.So you'd prefer CODESCODES and put CODESCODES there?

No CODESCODES module, i'm fine with thatI think I'd prefer that. Not yet certain how it generalises.


As long as we can figure out an appropriate place to put things like CODESCODES plot decision boundary CODESCODES, I'll vote thumbs up for CODESCODES sklearn. XXX. plot CODESCODES.Does this need a slep? we don't seem to be making much progress

EDIT ugh, sleepy me read Joel's comment as I don't think I'd prefer that, sorry

I'm fine with either solution CODESCODES sklearn. plot CODESCODES CODESCODES sklearn. XXX. plot CODESCODES. The main issue here IMO is that no one tells me where shall we put things like CODESCODES plot decision boundary CODESCODES if we use CODESCODES sklearn. XXX. plot CODESCODES thumbs up  CODESCODES?

Interesting idea, I'll vote thumbs up. Maybe it's not so good to throw all the things to sklearn. plot LINKLINK put all the plotting functions in a single module.

So we'll support CODESCODES from sklearn. XXX. plot import plot XXX CODESCODES? Will we support CODESCODES from sklearn. XXX import plot XXX CODESCODES?I think the explicit requirement of. plot in the import is something
others here have sought.

There's also the inverted from sklearn. plot. XXX import plot YYY


So we've reached consensus to use CODESCODES sklearn. XXX. plot CODESCODES only support from CODESCODES sklearn. XXX. plot CODESCODES import CODESCODES plot XXX CODESCODES?



I can't understand.


I meant that we could have
sklearn. plot. model inspection. plot partial dependence rather than
sklearn. model inspection. plot. plot partial dependence. Not sure if this
provides any benefit clarity.

sklearn. plot. model inspection. plot partial dependence rather than
sklearn. model inspection. plot. plot partial dependence. Not sure if this
provides any benefit clarity.

So now we have 3 options:
 1 sklearn. plot. plot YYY for example, sklearn. plot. plot tree 
 2 sklearn. plot. XXX. plot YYY for example, sklearn. plot. tree. plot tree 
 3 sklearn. XXX. plot. plot YYY for example, sklearn. tree. plot. plot tree, do not support from sklearn. XXX import plot YYY 
I'll vote thumbs up for all these solutions.
I prefer to make the decision before 0.21 to avoid deprecating sklearn. tree. plot treeNot sure it needs a slep but might be worth inviting opinions on the
mailing list


 thumbs up. It does not fall in the criteria of SLEPs, it seems.
As I said on the mailing list, I think we should really also consider where the work happens or what the interface will be like. That was already quite unclear for partial dependence.
Should CODESCODES plot partial dependence CODESCODES call to CODESCODES partial dependence CODESCODES or get the output of CODESCODES partial dependence CODESCODES as input? This questions is a valid question for basically all plot functions.
The main consideration I discusses with NicolasHug is that having CODESCODES plot X CODESCODES call CODESCODES compute X CODESCODES is convenient for the user as long as they only want to plot the thing once. If they don't like the plot and want to change something, they need to CODESCODES compute X CODESCODES again, which is potentially a waste.

So we could either
 always take the result of CODESCODES compute X CODESCODES. downside: inconvenient and error prone: what was the order of precision, recall and thresholds again in precision recall curve?

 always the take the input to CODESCODES compute X CODESCODES and call CODESCODES compute X CODESCODES from CODESCODES plot X CODESCODES. downside: you need to recompute for every plot.

 allow both, so CODESCODES plot X CODESCODES can take either the input to CODESCODES compute X CODESCODES and call to CODESCODES compute X CODESCODES or take the output of CODESCODES compute X CODESCODES if the user already created it. That has the downside of complicating the signature and possibly complicates documenting it. Also, if the user calls CODESCODES plot X CODESCODES so that it internally does CODESCODES compute X CODESCODES and then wants another plot, she needs to CODESCODES compute X CODESCODES again. So you need to to anticipate that you want more than one plot before calling CODESCODES plot X CODESCODES the first time. Or you need to expose the result of CODESCODES compute X CODESCODES when calling CODESCODES plot X CODESCODES, but it's unclear to me how to do that without an object oriented design

 make the decision depending on how expensive compute X is, as for confusion matrix and partial dependence plots and calibration plots we don't care about the cost of recomputing, but for partial dependence plots we do. downside: inconsistent interface.

 thumbs up 000. It's a common problem that I see in research code. 

From a design problem, it violates an MVC separation slightly pedantic,
sorry.

In the various solutions that you propose, would you consider taking a
fitted model as an approach? I feel that it would mitigate the problem of
remembering the order of parameters. But maybe there are additional
problems.
I'm not sure what you mean by fitted model. Often the output of computation is not a fitted model. We could define objects for all of the computation results, so that CODESCODES partial dependence CODESCODES returns a CODESCODES PartialDependence CODESCODES object. Or a bunch. But it doesn't return an estimator.

Oh the reason I bring this up now: without this decision I have no idea what user code will look like, and I don't like making naming API decisions without being able to write down examples thumbs up returning an object would be pretty un sklearn like, imho. But it might solve the location problem: it could have a CODESCODES plot CODESCODES methods thumbs up 

Point taken.

One option not saying that it is the best one would be to have all the
compute functions return named tuples and all the corresponding compute
functions take this. It would be somewhat consistent with modern
additions to the Python standard library.



I'm like you.

So if the computation is expensive, we can do the computation outside the function. If so, we return an object and the plotting function take this object as its input, right? I'll vote thumbs up.

And maybe we need another issue to discuss this thumbs up The benefit of GaelVaroquaux's suggestion is that it might not require users to change their code because of tuple unpacking. But that wouldn't work if there's a single returned object like in CODESCODES confusion matrix CODESCODES. There a tuple would not be strictly necessary but then the interface becomes slightly inconsistent.

 qinhanmin2014 if we return arbitrary objects we have to deprecate the return type for a function every time we create a plotting helper. That seems like a mess.

I had one idea, and then a second better idea:
1 create a second, object oriented interface that calls the existing function, stores the object, and has a plot method, like
 CODELCODEL 
That would solve the problem, but would duplicate some interface and it would be a bit unclear. Actually the same principle can be done in a way that I think is more intuitive:
2 have the CODESCODES plot CODESCODES function always do the work, use the result to instantiate an object that stores the result and plots it:
 CODELCODEL 
would therefor just plot, and return a CODESCODES ConfusionMatrixPlotter CODESCODES object, that stores the result, and has a CODESCODES plot CODESCODES method.
So in the simple case of just plotting once, it's just a single function call. If you then want the results to do something else with it, they are stored in the object. If you want to plot again, you can just call CODESCODES plot CODESCODES on the object again. If you already computed the results and then decide you want to plot, you can instantiate CODESCODES ConfusionMatrixPlotter CODESCODES directly.

While this exposes an additional class for the more complex use cases, I think it's a reasonable trade off because it has a nice answer to all the situations.

Why do users need to plot the same data again? amueller adjust the format? qinhanmin2014 yes, make the font bigger, change the colors, plot it with something else together in the same plot, add labels, 

I doubt whether itâs worthwhile to consider these formatting issues here. Users can start will a small part of the dataset?And amueller weâll support passing axes, so users can easily adjust the plot after they call the plotting functions? qinhanmin2014 no, many things can not easily be changed afterwards, and we don't need to think about all the formatting necessarily ourselves, but we should allow users to plot something again. It will basically happen any time you do a plot. And having to subsample datasets every time I want to do a plot is a bit annoying. And if I later change my mind I will still need to recompute.
Basically the point is that you can't usually anticipate what exactly you want in your exploratory analysis, and having to recompute everything to change a visualization doesn't seem great.

Yes, I know it might be useful, but the main issue here is that we don't have a clean way to support this functionality, and I guess most plotting functions do not require much calculation?I like that we're discussing this with a little more grounding, but tbh I'm
still not entirely convinced that we even need to have plot in the import
path at all. After all, we seem to have plot as a prefix for the
functions. The question also relates to plot tree: why should it be
separated from other export and textual visualisation code?
 qinhanmin2014 I don't think we don't have a good API yet is a good reason.
And partial dependence, permutation importance, learning curves, validation curves and results of GridSearchCV and RandomizedSearchCV are all common examples that take a lot of computation. Though for gridsearchcv and randomizedsearchcv the obvious thing would be to pass either the object or the CODESCODES cv results CODESCODES, doing the work inside the plotting function in those cases seems nonsensical. I'm not entirely sure about learning curves and validation curves tbh. jnothman I think GaelVaroquaux wanted to keep the matplotlib dependency confined to a module and that was one of the main motivations? I don't really have very coherent thoughts about this yet.

Thanks, I now realized that I'm wrong thumbs up 
Though I'm still unable to understand why it's important to provide users with a way to plot without recomputing. But if others think so and there's a good way, I'll vote thumbs up.


still not entirely convinced that we even need to have plot in the import
path at all. After all, we seem to have plot as a prefix for the
functions. The question also relates to plot tree: why should it be
separated from other export and textual visualisation code?

Yes this can also be an option. If so, we can mention that all the functions which start with CODESCODES plot CODESCODES requires matplotlib. Another advantage of this option is that we don't need to move existing functions.Going over this discussion, I agree with not adding a CODESCODES module, and use the prefix CODESCODES to signal a CODESCODES requirement. 

For example, in LINKLINK, CODESCODES and CODESCODES will be placed in CODESCODES.Ok, unless someone disagrees with this in the following days, I'm going to update the PDP PR and:

 put both CODESCODES and CODESCODES in CODESCODES 
 make CODESCODES return a bunch with the CODESCODES and CODESCODES objects as attributes right now it returns them in a tuple. This way, we'll be able to keep these 2 functions backward compatible when we implement the second option from LINKLINK Can we make the final decision here?
Proposal agreed by jnothman, NicolasHug and me apologies if I'm wrong: sklearn. XXX. plot YYY support from sklearn. XXX import plot YYY. We'll mention that all the functions which start with plot requires matplotlib.
A major advantage of this proposal is that we don't need to move existing functions.Sleeping over it I think itâs simple enough to explain and it avoids the difficulty to think of a shared plotting api between different modules. 
Yes, let's do that. Make a helper function to provide a more helpful
ImportError
FYI, I'm adding CODESCODES in 12599 

 CODELCODEL 

That's great! Thanks.